// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: backup.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	v11 "github.com/arangodb-managed/apis/data/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// BackupPolicy represents a single backup policy for a deployment.
type BackupPolicy struct {
	// System identifier of the backup policy.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the backup policy
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Identifier of the deployment that owns this backup policy.
	// After creation, this value cannot be changed.
	DeploymentId string `protobuf:"bytes,4,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// The creation timestamp of the backup policy
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the backup policy
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,6,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this backup policy is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,7,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Pause this backup policy.
	// When a backup policy is paused, the backup policy will not result in new backups.
	// The backup policy isn't deleted, unsetting this field will resume the creation of backups again.
	IsPaused bool `protobuf:"varint,8,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// The schedule for this backup policy
	Schedule *BackupPolicy_Schedule `protobuf:"bytes,9,opt,name=schedule,proto3" json:"schedule,omitempty"`
	// Upload the backup, created by the backup policy, to an external source.
	Upload bool `protobuf:"varint,10,opt,name=upload,proto3" json:"upload,omitempty"`
	// Backups created by this policy will be automatically deleted after the specified duration
	// A value of 0 means that backup will never be deleted.
	AutoDeleteAfter *types.Duration `protobuf:"bytes,11,opt,name=auto_delete_after,json=autoDeleteAfter,proto3" json:"auto_delete_after,omitempty"`
	// The owners of the organization can be notified by email
	// This field support the following values: "None|FailureOnly|Always"
	EmailNotification string `protobuf:"bytes,12,opt,name=email_notification,json=emailNotification,proto3" json:"email_notification,omitempty"`
	// Status of the backup policy
	Status               *BackupPolicy_Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *BackupPolicy) Reset()         { *m = BackupPolicy{} }
func (m *BackupPolicy) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy) ProtoMessage()    {}
func (*BackupPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0}
}
func (m *BackupPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy.Merge(m, src)
}
func (m *BackupPolicy) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy proto.InternalMessageInfo

func (m *BackupPolicy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BackupPolicy) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BackupPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BackupPolicy) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *BackupPolicy) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *BackupPolicy) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *BackupPolicy) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *BackupPolicy) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

func (m *BackupPolicy) GetSchedule() *BackupPolicy_Schedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *BackupPolicy) GetUpload() bool {
	if m != nil {
		return m.Upload
	}
	return false
}

func (m *BackupPolicy) GetAutoDeleteAfter() *types.Duration {
	if m != nil {
		return m.AutoDeleteAfter
	}
	return nil
}

func (m *BackupPolicy) GetEmailNotification() string {
	if m != nil {
		return m.EmailNotification
	}
	return ""
}

func (m *BackupPolicy) GetStatus() *BackupPolicy_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type BackupPolicy_Schedule struct {
	// Schedule type should be one of the following string: "Hourly|Daily|Monthly"
	// The schedule_hourly, schedule_daily or schedule_montly field should be set
	// Setting multiple fields, or inconsistent with this field result in an error during create/update
	ScheduleType string `protobuf:"bytes,1,opt,name=schedule_type,json=scheduleType,proto3" json:"schedule_type,omitempty"`
	// Schedule applies to the selected day of the week
	// This is applicable for Daily type only, ignored for Hourly and Monthly
	ScheduleHourly *BackupPolicy_Schedule_HourlySchedule `protobuf:"bytes,2,opt,name=schedule_hourly,json=scheduleHourly,proto3" json:"schedule_hourly,omitempty"`
	// Schedule applies to the selected day of the week
	// This is applicable for Daily type only, ignored for Hourly and Monthly
	ScheduleDaily *BackupPolicy_Schedule_DailySchedule `protobuf:"bytes,3,opt,name=schedule_daily,json=scheduleDaily,proto3" json:"schedule_daily,omitempty"`
	// Schedule applies to the selected day of the month
	// This is applicable for Monthly type only, ignored for Hourly and Daily
	ScheduleMonthly *BackupPolicy_Schedule_MonthlySchedule `protobuf:"bytes,4,opt,name=schedule_monthly,json=scheduleMonthly,proto3" json:"schedule_monthly,omitempty"`
	// The resulting cron notation of this schedule used by the system
	// This is a read-only value.
	CronSchedule         string   `protobuf:"bytes,10,opt,name=cronSchedule,proto3" json:"cronSchedule,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupPolicy_Schedule) Reset()         { *m = BackupPolicy_Schedule{} }
func (m *BackupPolicy_Schedule) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy_Schedule) ProtoMessage()    {}
func (*BackupPolicy_Schedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0, 0}
}
func (m *BackupPolicy_Schedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy_Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy_Schedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy_Schedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy_Schedule.Merge(m, src)
}
func (m *BackupPolicy_Schedule) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy_Schedule) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy_Schedule.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy_Schedule proto.InternalMessageInfo

func (m *BackupPolicy_Schedule) GetScheduleType() string {
	if m != nil {
		return m.ScheduleType
	}
	return ""
}

func (m *BackupPolicy_Schedule) GetScheduleHourly() *BackupPolicy_Schedule_HourlySchedule {
	if m != nil {
		return m.ScheduleHourly
	}
	return nil
}

func (m *BackupPolicy_Schedule) GetScheduleDaily() *BackupPolicy_Schedule_DailySchedule {
	if m != nil {
		return m.ScheduleDaily
	}
	return nil
}

func (m *BackupPolicy_Schedule) GetScheduleMonthly() *BackupPolicy_Schedule_MonthlySchedule {
	if m != nil {
		return m.ScheduleMonthly
	}
	return nil
}

func (m *BackupPolicy_Schedule) GetCronSchedule() string {
	if m != nil {
		return m.CronSchedule
	}
	return ""
}

type BackupPolicy_Schedule_HourlySchedule struct {
	// Schedule should run with an interval of the specified hours
	// This is applicable for Hourly type only, ignored for Daily and Monthly
	ScheduleEveryIntervalHours int32    `protobuf:"varint,1,opt,name=schedule_every_interval_hours,json=scheduleEveryIntervalHours,proto3" json:"schedule_every_interval_hours,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *BackupPolicy_Schedule_HourlySchedule) Reset()         { *m = BackupPolicy_Schedule_HourlySchedule{} }
func (m *BackupPolicy_Schedule_HourlySchedule) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy_Schedule_HourlySchedule) ProtoMessage()    {}
func (*BackupPolicy_Schedule_HourlySchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0, 0, 0}
}
func (m *BackupPolicy_Schedule_HourlySchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy_Schedule_HourlySchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy_Schedule_HourlySchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy_Schedule_HourlySchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy_Schedule_HourlySchedule.Merge(m, src)
}
func (m *BackupPolicy_Schedule_HourlySchedule) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy_Schedule_HourlySchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy_Schedule_HourlySchedule.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy_Schedule_HourlySchedule proto.InternalMessageInfo

func (m *BackupPolicy_Schedule_HourlySchedule) GetScheduleEveryIntervalHours() int32 {
	if m != nil {
		return m.ScheduleEveryIntervalHours
	}
	return 0
}

type BackupPolicy_Schedule_DailySchedule struct {
	// Run the backup on Monday
	Monday bool `protobuf:"varint,1,opt,name=monday,proto3" json:"monday,omitempty"`
	// Run the backup on Tuesday
	Tuesday bool `protobuf:"varint,2,opt,name=tuesday,proto3" json:"tuesday,omitempty"`
	// Run the backup on Wednesday
	Wednesday bool `protobuf:"varint,3,opt,name=wednesday,proto3" json:"wednesday,omitempty"`
	// Run the backup on Thursday
	Thursday bool `protobuf:"varint,4,opt,name=thursday,proto3" json:"thursday,omitempty"`
	// Run the backup on Friday
	Friday bool `protobuf:"varint,5,opt,name=friday,proto3" json:"friday,omitempty"`
	// Run the backup on Saturday
	Saturday bool `protobuf:"varint,6,opt,name=saturday,proto3" json:"saturday,omitempty"`
	// Run the backup on Sunday
	Sunday bool `protobuf:"varint,7,opt,name=sunday,proto3" json:"sunday,omitempty"`
	// The (target) time of the schedule
	// We ignore the date part, and concidering the time part (including time-zone) only.
	// TODO: Better type...
	ScheduleAt           *types.Timestamp `protobuf:"bytes,10,opt,name=schedule_at,json=scheduleAt,proto3" json:"schedule_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BackupPolicy_Schedule_DailySchedule) Reset()         { *m = BackupPolicy_Schedule_DailySchedule{} }
func (m *BackupPolicy_Schedule_DailySchedule) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy_Schedule_DailySchedule) ProtoMessage()    {}
func (*BackupPolicy_Schedule_DailySchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0, 0, 1}
}
func (m *BackupPolicy_Schedule_DailySchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy_Schedule_DailySchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy_Schedule_DailySchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy_Schedule_DailySchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy_Schedule_DailySchedule.Merge(m, src)
}
func (m *BackupPolicy_Schedule_DailySchedule) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy_Schedule_DailySchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy_Schedule_DailySchedule.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy_Schedule_DailySchedule proto.InternalMessageInfo

func (m *BackupPolicy_Schedule_DailySchedule) GetMonday() bool {
	if m != nil {
		return m.Monday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetTuesday() bool {
	if m != nil {
		return m.Tuesday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetWednesday() bool {
	if m != nil {
		return m.Wednesday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetThursday() bool {
	if m != nil {
		return m.Thursday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetFriday() bool {
	if m != nil {
		return m.Friday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetSaturday() bool {
	if m != nil {
		return m.Saturday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetSunday() bool {
	if m != nil {
		return m.Sunday
	}
	return false
}

func (m *BackupPolicy_Schedule_DailySchedule) GetScheduleAt() *types.Timestamp {
	if m != nil {
		return m.ScheduleAt
	}
	return nil
}

type BackupPolicy_Schedule_MonthlySchedule struct {
	// Run the backup on the first day of the month
	First bool `protobuf:"varint,1,opt,name=first,proto3" json:"first,omitempty"`
	// Run the backup on the last day of the month
	Last bool `protobuf:"varint,2,opt,name=last,proto3" json:"last,omitempty"`
	// Run the backup on the specified day of the month
	DayOfMonth int32 `protobuf:"varint,3,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// The (target) time of the schedule
	// We ignore the date part, and concidering the time part (including time-zone) only.
	// TODO: Better type...
	ScheduleAt           *types.Timestamp `protobuf:"bytes,10,opt,name=schedule_at,json=scheduleAt,proto3" json:"schedule_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BackupPolicy_Schedule_MonthlySchedule) Reset()         { *m = BackupPolicy_Schedule_MonthlySchedule{} }
func (m *BackupPolicy_Schedule_MonthlySchedule) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy_Schedule_MonthlySchedule) ProtoMessage()    {}
func (*BackupPolicy_Schedule_MonthlySchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0, 0, 2}
}
func (m *BackupPolicy_Schedule_MonthlySchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy_Schedule_MonthlySchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy_Schedule_MonthlySchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy_Schedule_MonthlySchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy_Schedule_MonthlySchedule.Merge(m, src)
}
func (m *BackupPolicy_Schedule_MonthlySchedule) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy_Schedule_MonthlySchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy_Schedule_MonthlySchedule.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy_Schedule_MonthlySchedule proto.InternalMessageInfo

func (m *BackupPolicy_Schedule_MonthlySchedule) GetFirst() bool {
	if m != nil {
		return m.First
	}
	return false
}

func (m *BackupPolicy_Schedule_MonthlySchedule) GetLast() bool {
	if m != nil {
		return m.Last
	}
	return false
}

func (m *BackupPolicy_Schedule_MonthlySchedule) GetDayOfMonth() int32 {
	if m != nil {
		return m.DayOfMonth
	}
	return 0
}

func (m *BackupPolicy_Schedule_MonthlySchedule) GetScheduleAt() *types.Timestamp {
	if m != nil {
		return m.ScheduleAt
	}
	return nil
}

// Status of the backup policy
// All members of this field are read-only.
type BackupPolicy_Status struct {
	// The timestamp when the next backup - initiated by this backup policy - will be created
	NextBackup *types.Timestamp `protobuf:"bytes,1,opt,name=next_backup,json=nextBackup,proto3" json:"next_backup,omitempty"`
	// Message in case of failure, otherwise an empty string
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupPolicy_Status) Reset()         { *m = BackupPolicy_Status{} }
func (m *BackupPolicy_Status) String() string { return proto.CompactTextString(m) }
func (*BackupPolicy_Status) ProtoMessage()    {}
func (*BackupPolicy_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{0, 1}
}
func (m *BackupPolicy_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicy_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicy_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicy_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicy_Status.Merge(m, src)
}
func (m *BackupPolicy_Status) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicy_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicy_Status.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicy_Status proto.InternalMessageInfo

func (m *BackupPolicy_Status) GetNextBackup() *types.Timestamp {
	if m != nil {
		return m.NextBackup
	}
	return nil
}

func (m *BackupPolicy_Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// List of backup policies.
type BackupPolicyList struct {
	Items                []*BackupPolicy `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BackupPolicyList) Reset()         { *m = BackupPolicyList{} }
func (m *BackupPolicyList) String() string { return proto.CompactTextString(m) }
func (*BackupPolicyList) ProtoMessage()    {}
func (*BackupPolicyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{1}
}
func (m *BackupPolicyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupPolicyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupPolicyList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupPolicyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupPolicyList.Merge(m, src)
}
func (m *BackupPolicyList) XXX_Size() int {
	return m.Size()
}
func (m *BackupPolicyList) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupPolicyList.DiscardUnknown(m)
}

var xxx_messageInfo_BackupPolicyList proto.InternalMessageInfo

func (m *BackupPolicyList) GetItems() []*BackupPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListBackupPolicies
type ListBackupPoliciesRequest struct {
	// Common list options, the context_id should refer to a deployment_id
	Options *v1.ListOptions `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	// If set, the result includes all backup providers, including those who set to deleted,
	// however are not removed from the systemare available for the
	// If not set, only backup providers not indicated as delted are returne.
	IncludeDeleted       bool     `protobuf:"varint,2,opt,name=include_deleted,json=includeDeleted,proto3" json:"include_deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBackupPoliciesRequest) Reset()         { *m = ListBackupPoliciesRequest{} }
func (m *ListBackupPoliciesRequest) String() string { return proto.CompactTextString(m) }
func (*ListBackupPoliciesRequest) ProtoMessage()    {}
func (*ListBackupPoliciesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{2}
}
func (m *ListBackupPoliciesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBackupPoliciesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBackupPoliciesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBackupPoliciesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBackupPoliciesRequest.Merge(m, src)
}
func (m *ListBackupPoliciesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBackupPoliciesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBackupPoliciesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBackupPoliciesRequest proto.InternalMessageInfo

func (m *ListBackupPoliciesRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListBackupPoliciesRequest) GetIncludeDeleted() bool {
	if m != nil {
		return m.IncludeDeleted
	}
	return false
}

// Backup represents a single backup for a deployment.
type Backup struct {
	// System identifier of the backup.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Description of the backup
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the deployment that owns this backup policy.
	// After creation, this value cannot be changed.
	DeploymentId string `protobuf:"bytes,4,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Identifier of the backup policy that triggered this backup
	// After creation, this value cannot be changed.
	// If this field is empty, this is a manual backup
	BackupPolicyId string `protobuf:"bytes,5,opt,name=backup_policy_id,json=backupPolicyId,proto3" json:"backup_policy_id,omitempty"`
	// The creation timestamp of the backup (database object)
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the backup
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,7,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this backup is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,8,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// The timestamp that this backup will be automatically removed
	AutoDeletedAt *types.Timestamp `protobuf:"bytes,9,opt,name=auto_deleted_at,json=autoDeletedAt,proto3" json:"auto_deleted_at,omitempty"`
	// Information about the deployment during backup
	DeploymentInfo *Backup_DeploymentInfo `protobuf:"bytes,10,opt,name=deployment_info,json=deploymentInfo,proto3" json:"deployment_info,omitempty"`
	// Status of the actual backup
	Status               *Backup_Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Backup) Reset()         { *m = Backup{} }
func (m *Backup) String() string { return proto.CompactTextString(m) }
func (*Backup) ProtoMessage()    {}
func (*Backup) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{3}
}
func (m *Backup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Backup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Backup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backup.Merge(m, src)
}
func (m *Backup) XXX_Size() int {
	return m.Size()
}
func (m *Backup) XXX_DiscardUnknown() {
	xxx_messageInfo_Backup.DiscardUnknown(m)
}

var xxx_messageInfo_Backup proto.InternalMessageInfo

func (m *Backup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Backup) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Backup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Backup) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Backup) GetBackupPolicyId() string {
	if m != nil {
		return m.BackupPolicyId
	}
	return ""
}

func (m *Backup) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Backup) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Backup) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *Backup) GetAutoDeletedAt() *types.Timestamp {
	if m != nil {
		return m.AutoDeletedAt
	}
	return nil
}

func (m *Backup) GetDeploymentInfo() *Backup_DeploymentInfo {
	if m != nil {
		return m.DeploymentInfo
	}
	return nil
}

func (m *Backup) GetStatus() *Backup_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Information about the deployment during backup
// All members of this field are read-only.
type Backup_DeploymentInfo struct {
	// ArangoDB version of the deployment during backup.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Servers spec of the deployment during backup.
	Servers              *v11.Deployment_ServersSpec `protobuf:"bytes,2,opt,name=servers,proto3" json:"servers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Backup_DeploymentInfo) Reset()         { *m = Backup_DeploymentInfo{} }
func (m *Backup_DeploymentInfo) String() string { return proto.CompactTextString(m) }
func (*Backup_DeploymentInfo) ProtoMessage()    {}
func (*Backup_DeploymentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{3, 0}
}
func (m *Backup_DeploymentInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backup_DeploymentInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Backup_DeploymentInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Backup_DeploymentInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backup_DeploymentInfo.Merge(m, src)
}
func (m *Backup_DeploymentInfo) XXX_Size() int {
	return m.Size()
}
func (m *Backup_DeploymentInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Backup_DeploymentInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Backup_DeploymentInfo proto.InternalMessageInfo

func (m *Backup_DeploymentInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Backup_DeploymentInfo) GetServers() *v11.Deployment_ServersSpec {
	if m != nil {
		return m.Servers
	}
	return nil
}

// Status of the actual backup
// All members of this field are read-only.
type Backup_Status struct {
	// The id of the backup
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The creation timestamp of the backup
	CreatedAt *types.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// ArangoDB version of the backup
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// The state of the backup
	// Will be one of the following: "Pending|...|Failed"
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// State message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// Progesss of the backup
	Progress string `protobuf:"bytes,6,opt,name=progress,proto3" json:"progress,omitempty"`
	// Size of the backup (in bytes)
	SizeBytes int32 `protobuf:"varint,7,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Set when the backup has been fully uploaded
	Uploaded bool `protobuf:"varint,8,opt,name=uploaded,proto3" json:"uploaded,omitempty"`
	// Set when the backup has been fully downloaded
	Downloaded bool `protobuf:"varint,9,opt,name=downloaded,proto3" json:"downloaded,omitempty"`
	// Set when the backup is available to restore to / recover from
	Available            bool     `protobuf:"varint,10,opt,name=available,proto3" json:"available,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Backup_Status) Reset()         { *m = Backup_Status{} }
func (m *Backup_Status) String() string { return proto.CompactTextString(m) }
func (*Backup_Status) ProtoMessage()    {}
func (*Backup_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{3, 1}
}
func (m *Backup_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backup_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Backup_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Backup_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backup_Status.Merge(m, src)
}
func (m *Backup_Status) XXX_Size() int {
	return m.Size()
}
func (m *Backup_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Backup_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Backup_Status proto.InternalMessageInfo

func (m *Backup_Status) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Backup_Status) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Backup_Status) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Backup_Status) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Backup_Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Backup_Status) GetProgress() string {
	if m != nil {
		return m.Progress
	}
	return ""
}

func (m *Backup_Status) GetSizeBytes() int32 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *Backup_Status) GetUploaded() bool {
	if m != nil {
		return m.Uploaded
	}
	return false
}

func (m *Backup_Status) GetDownloaded() bool {
	if m != nil {
		return m.Downloaded
	}
	return false
}

func (m *Backup_Status) GetAvailable() bool {
	if m != nil {
		return m.Available
	}
	return false
}

// List of backups.
type BackupList struct {
	Items                []*Backup `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BackupList) Reset()         { *m = BackupList{} }
func (m *BackupList) String() string { return proto.CompactTextString(m) }
func (*BackupList) ProtoMessage()    {}
func (*BackupList) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{4}
}
func (m *BackupList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupList.Merge(m, src)
}
func (m *BackupList) XXX_Size() int {
	return m.Size()
}
func (m *BackupList) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupList.DiscardUnknown(m)
}

var xxx_messageInfo_BackupList proto.InternalMessageInfo

func (m *BackupList) GetItems() []*Backup {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListBackups
type ListBackupsRequest struct {
	// Common list options, the context_id should refer to a deployment_id
	Options              *v1.ListOptions `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListBackupsRequest) Reset()         { *m = ListBackupsRequest{} }
func (m *ListBackupsRequest) String() string { return proto.CompactTextString(m) }
func (*ListBackupsRequest) ProtoMessage()    {}
func (*ListBackupsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_65240d19de191688, []int{5}
}
func (m *ListBackupsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBackupsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBackupsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBackupsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBackupsRequest.Merge(m, src)
}
func (m *ListBackupsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBackupsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBackupsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBackupsRequest proto.InternalMessageInfo

func (m *ListBackupsRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func init() {
	proto.RegisterType((*BackupPolicy)(nil), "arangodb.cloud.backup.v1.BackupPolicy")
	proto.RegisterType((*BackupPolicy_Schedule)(nil), "arangodb.cloud.backup.v1.BackupPolicy.Schedule")
	proto.RegisterType((*BackupPolicy_Schedule_HourlySchedule)(nil), "arangodb.cloud.backup.v1.BackupPolicy.Schedule.HourlySchedule")
	proto.RegisterType((*BackupPolicy_Schedule_DailySchedule)(nil), "arangodb.cloud.backup.v1.BackupPolicy.Schedule.DailySchedule")
	proto.RegisterType((*BackupPolicy_Schedule_MonthlySchedule)(nil), "arangodb.cloud.backup.v1.BackupPolicy.Schedule.MonthlySchedule")
	proto.RegisterType((*BackupPolicy_Status)(nil), "arangodb.cloud.backup.v1.BackupPolicy.Status")
	proto.RegisterType((*BackupPolicyList)(nil), "arangodb.cloud.backup.v1.BackupPolicyList")
	proto.RegisterType((*ListBackupPoliciesRequest)(nil), "arangodb.cloud.backup.v1.ListBackupPoliciesRequest")
	proto.RegisterType((*Backup)(nil), "arangodb.cloud.backup.v1.Backup")
	proto.RegisterType((*Backup_DeploymentInfo)(nil), "arangodb.cloud.backup.v1.Backup.DeploymentInfo")
	proto.RegisterType((*Backup_Status)(nil), "arangodb.cloud.backup.v1.Backup.Status")
	proto.RegisterType((*BackupList)(nil), "arangodb.cloud.backup.v1.BackupList")
	proto.RegisterType((*ListBackupsRequest)(nil), "arangodb.cloud.backup.v1.ListBackupsRequest")
}

func init() { proto.RegisterFile("backup.proto", fileDescriptor_65240d19de191688) }

var fileDescriptor_65240d19de191688 = []byte{
	// 1501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4b, 0x6f, 0x1b, 0xd5,
	0x17, 0xff, 0x8f, 0x53, 0x3b, 0xf6, 0xb1, 0xf3, 0xe8, 0x55, 0x55, 0xb9, 0xfe, 0xb7, 0x69, 0x34,
	0x6d, 0x69, 0x14, 0x91, 0x31, 0x71, 0x45, 0xd5, 0xd2, 0x47, 0x94, 0x34, 0x11, 0xad, 0x78, 0xb4,
	0x9a, 0xb4, 0x12, 0x62, 0x63, 0x5d, 0x7b, 0xae, 0x9d, 0x0b, 0xe3, 0xb9, 0xc3, 0xdc, 0x3b, 0x6e,
	0x4d, 0xd5, 0x05, 0x88, 0x87, 0xc4, 0x86, 0x45, 0x37, 0x88, 0x1d, 0x3b, 0xd8, 0xb2, 0x44, 0x7c,
	0x00, 0x36, 0x48, 0x48, 0x7c, 0x01, 0x54, 0xf8, 0x20, 0xe8, 0x3e, 0x66, 0x3c, 0x76, 0x49, 0x6c,
	0x97, 0xb2, 0xca, 0x3d, 0xef, 0x73, 0xcf, 0xf9, 0xdd, 0x73, 0xc6, 0x81, 0x4a, 0x0b, 0xb7, 0x3f,
	0x8c, 0x43, 0x27, 0x8c, 0x98, 0x60, 0xa8, 0x8a, 0x23, 0x1c, 0x74, 0x99, 0xd7, 0x72, 0xda, 0x3e,
	0x8b, 0x3d, 0xc7, 0x08, 0xfb, 0x9b, 0x35, 0xe4, 0x61, 0x81, 0xeb, 0xfd, 0xcd, 0xba, 0xfc, 0xab,
	0xb5, 0x6b, 0x27, 0xdb, 0xac, 0xd7, 0x63, 0x81, 0xe4, 0xea, 0x93, 0xe1, 0x5f, 0xeb, 0x52, 0x71,
	0x10, 0xb7, 0x9c, 0x36, 0xeb, 0xd5, 0xbb, 0xcc, 0xc7, 0x41, 0xb7, 0xae, 0x04, 0xad, 0xb8, 0x53,
	0x0f, 0xc5, 0x20, 0x24, 0xbc, 0x2e, 0x68, 0x8f, 0x70, 0x81, 0x7b, 0xe1, 0xf0, 0x64, 0x8c, 0xaf,
	0x4e, 0x36, 0xf6, 0xe2, 0x08, 0x0b, 0xca, 0x82, 0xf4, 0x60, 0x4c, 0x4f, 0x77, 0x19, 0xeb, 0xfa,
	0xa4, 0x8e, 0x43, 0x5a, 0xc7, 0x41, 0xc0, 0x84, 0x12, 0x72, 0x2d, 0xb5, 0xbf, 0xaf, 0x40, 0x65,
	0x47, 0xdd, 0xe7, 0x1e, 0xf3, 0x69, 0x7b, 0x80, 0x16, 0x21, 0x47, 0xbd, 0xaa, 0xb5, 0x6a, 0xad,
	0x95, 0xdc, 0x1c, 0xf5, 0xd0, 0x32, 0xcc, 0xc5, 0x91, 0x5f, 0xcd, 0x29, 0x86, 0x3c, 0x22, 0x04,
	0xc7, 0x02, 0xdc, 0x23, 0xd5, 0x39, 0xc5, 0x52, 0x67, 0x74, 0x0e, 0x16, 0x3c, 0x12, 0xfa, 0x6c,
	0xd0, 0x23, 0x81, 0x68, 0x52, 0xaf, 0x7a, 0x4c, 0x09, 0x2b, 0x43, 0xe6, 0x1d, 0x0f, 0x5d, 0x05,
	0x68, 0x47, 0x04, 0x0b, 0xe2, 0x35, 0xb1, 0xa8, 0xe6, 0x57, 0xad, 0xb5, 0x72, 0xa3, 0xe6, 0xe8,
	0xf4, 0x9c, 0xe4, 0x3a, 0xce, 0xfd, 0xe4, 0xea, 0x6e, 0xc9, 0x68, 0x6f, 0x0b, 0x69, 0xea, 0x11,
	0x9f, 0x18, 0xd3, 0xc2, 0x64, 0x53, 0xa3, 0xbd, 0x2d, 0xd0, 0x19, 0x00, 0xca, 0x9b, 0x86, 0xae,
	0xce, 0xaf, 0x5a, 0x6b, 0x45, 0xb7, 0x44, 0xf9, 0xae, 0x66, 0xa0, 0xff, 0x43, 0x89, 0xf2, 0x66,
	0x88, 0x63, 0x4e, 0xbc, 0x6a, 0x51, 0x49, 0x8b, 0x94, 0xdf, 0x53, 0x34, 0x7a, 0x0b, 0x8a, 0xbc,
	0x7d, 0x40, 0xbc, 0xd8, 0x27, 0xd5, 0x92, 0x0a, 0x5a, 0x77, 0x0e, 0x03, 0x83, 0x93, 0x2d, 0xa3,
	0xb3, 0x6f, 0xcc, 0xdc, 0xd4, 0x01, 0x3a, 0x09, 0x85, 0x38, 0xf4, 0x19, 0xf6, 0xaa, 0xa0, 0xc2,
	0x18, 0x0a, 0xed, 0xc1, 0x71, 0x1c, 0x0b, 0x66, 0x52, 0x6c, 0xe2, 0x8e, 0x20, 0x51, 0xb5, 0xac,
	0xa2, 0x9d, 0x7a, 0xee, 0x8a, 0xbb, 0xa6, 0xb9, 0xee, 0x92, 0xb4, 0xd1, 0x97, 0xd8, 0x96, 0x16,
	0x68, 0x03, 0x10, 0xe9, 0x61, 0xea, 0x37, 0x03, 0x26, 0x68, 0x87, 0xb6, 0x95, 0x5a, 0xb5, 0xa2,
	0xfa, 0x70, 0x5c, 0x49, 0xde, 0xcd, 0x08, 0xd0, 0x1e, 0x14, 0xb8, 0xc0, 0x22, 0xe6, 0x55, 0x4f,
	0x85, 0xda, 0x98, 0xf6, 0x62, 0xca, 0xc8, 0x35, 0xc6, 0xb5, 0x2f, 0xe7, 0xa1, 0x98, 0xdc, 0x55,
	0xa2, 0x20, 0xb9, 0x6d, 0x53, 0x82, 0xd2, 0xc0, 0xa8, 0x92, 0x30, 0xef, 0x0f, 0x42, 0x82, 0xba,
	0xb0, 0x94, 0x2a, 0x1d, 0xb0, 0x38, 0xf2, 0x07, 0x0a, 0x5c, 0xe5, 0xc6, 0xcd, 0x19, 0x4b, 0xeb,
	0xdc, 0x56, 0xd6, 0x69, 0xa5, 0x17, 0x13, 0xb7, 0x9a, 0x8f, 0x3c, 0x48, 0x39, 0x4d, 0x0f, 0x53,
	0x7f, 0xa0, 0x10, 0x5b, 0x6e, 0xdc, 0x98, 0x35, 0xce, 0xae, 0x34, 0x4e, 0xc3, 0xa4, 0x57, 0x54,
	0x6c, 0xf4, 0x01, 0x2c, 0xa7, 0x51, 0x7a, 0x2c, 0x10, 0x07, 0xfe, 0x40, 0x81, 0xbf, 0xdc, 0xd8,
	0x9a, 0x35, 0xce, 0x3b, 0xda, 0x3c, 0x8d, 0x94, 0xd6, 0xc9, 0x08, 0x90, 0x0d, 0x95, 0x76, 0xc4,
	0x82, 0x44, 0x41, 0xe1, 0xa8, 0xe4, 0x8e, 0xf0, 0x6a, 0xfb, 0xb0, 0x38, 0x5a, 0x17, 0xb4, 0x0d,
	0x67, 0xd2, 0x0c, 0x49, 0x9f, 0x44, 0x83, 0x26, 0x0d, 0x04, 0x89, 0xfa, 0xd8, 0x57, 0xf5, 0xe7,
	0xaa, 0x4b, 0x79, 0xb7, 0x96, 0x28, 0xed, 0x49, 0x9d, 0x3b, 0x46, 0x45, 0xfa, 0xe2, 0xb5, 0xcf,
	0x72, 0xb0, 0x30, 0x52, 0x05, 0x09, 0xe6, 0x1e, 0x0b, 0x3c, 0x3c, 0x50, 0xd6, 0x45, 0xd7, 0x50,
	0xa8, 0x0a, 0xf3, 0x22, 0x26, 0x5c, 0x0a, 0x72, 0x4a, 0x90, 0x90, 0xe8, 0x34, 0x94, 0x1e, 0x12,
	0x2f, 0xd0, 0xb2, 0x39, 0xfd, 0x0c, 0x53, 0x06, 0xaa, 0x41, 0x51, 0x1c, 0xc4, 0x91, 0x12, 0x1e,
	0xd3, 0xaf, 0x30, 0xa1, 0x65, 0xac, 0x4e, 0x44, 0xa5, 0x24, 0xaf, 0x63, 0x69, 0x4a, 0xda, 0x70,
	0x2c, 0xe2, 0x48, 0x4a, 0x0a, 0xda, 0x26, 0xa1, 0xa5, 0x0d, 0x8f, 0x55, 0x7e, 0xfa, 0xc5, 0x1b,
	0x0a, 0x5d, 0x83, 0x72, 0x5a, 0x0c, 0x2c, 0x54, 0x05, 0x8f, 0x9e, 0x24, 0x90, 0xa8, 0x6f, 0x8b,
	0xda, 0xb7, 0x16, 0x2c, 0x8d, 0x35, 0x09, 0x9d, 0x80, 0x7c, 0x87, 0x46, 0x5c, 0x98, 0x3a, 0x68,
	0x42, 0xce, 0x48, 0x1f, 0x73, 0x61, 0x6a, 0xa0, 0xce, 0x68, 0x15, 0x2a, 0x1e, 0x1e, 0x34, 0x59,
	0x47, 0xe3, 0x44, 0xd5, 0x20, 0xef, 0x82, 0x87, 0x07, 0x77, 0x3b, 0xca, 0xeb, 0xbf, 0x4b, 0xae,
	0x09, 0x05, 0xfd, 0x36, 0xa5, 0x9b, 0x80, 0x3c, 0x12, 0x4d, 0x8d, 0x37, 0x95, 0xd8, 0x04, 0x37,
	0x52, 0x5d, 0x63, 0x52, 0x36, 0xb0, 0x47, 0x38, 0xc7, 0x5d, 0x62, 0x66, 0x7e, 0x42, 0xda, 0xf7,
	0x60, 0x39, 0x8b, 0xdb, 0xb7, 0x29, 0x17, 0xe8, 0x3a, 0xe4, 0xa9, 0x20, 0x3d, 0x89, 0xa1, 0xb9,
	0xb5, 0x72, 0xe3, 0x95, 0xe9, 0x20, 0xef, 0x6a, 0x23, 0xfb, 0x73, 0x0b, 0x4e, 0x49, 0x37, 0x19,
	0x19, 0x25, 0xdc, 0x25, 0x1f, 0xc5, 0x84, 0x0b, 0xb4, 0x05, 0xf3, 0x2c, 0x54, 0xbb, 0xca, 0x5c,
	0xe1, 0xc2, 0xb8, 0x77, 0xb3, 0x5f, 0xfb, 0x9b, 0x8e, 0xf4, 0x72, 0x57, 0x2b, 0xbb, 0x89, 0x15,
	0xba, 0x08, 0x4b, 0x34, 0x68, 0xfb, 0xb1, 0x47, 0xd2, 0xf1, 0xaf, 0xfb, 0xb1, 0x68, 0xd8, 0x66,
	0x07, 0xd8, 0x3f, 0xcd, 0x43, 0xc1, 0x5c, 0x7f, 0xf2, 0xfa, 0x5b, 0x85, 0xb2, 0x47, 0x78, 0x3b,
	0xa2, 0x2a, 0x8a, 0xd9, 0x82, 0x59, 0xd6, 0x74, 0xcb, 0x70, 0x0d, 0x96, 0x75, 0x71, 0x9a, 0xa1,
	0xaa, 0x89, 0xd4, 0xcb, 0x2b, 0xbd, 0xc5, 0x56, 0xa6, 0x54, 0xcf, 0xad, 0xcd, 0xc2, 0x8b, 0xaf,
	0xcd, 0xf9, 0x17, 0x5f, 0x9b, 0xc5, 0xf1, 0xb5, 0xb9, 0x03, 0x4b, 0x99, 0xa5, 0xa5, 0xdc, 0x97,
	0x26, 0xba, 0x5f, 0x18, 0xee, 0x2c, 0x19, 0xe2, 0x3d, 0x58, 0xca, 0xd6, 0x29, 0xe8, 0x30, 0x03,
	0xf9, 0x89, 0x4b, 0xd6, 0xd9, 0x1d, 0x96, 0x32, 0xe8, 0x30, 0x77, 0xd1, 0x1b, 0xa1, 0xd1, 0xd6,
	0xd8, 0x72, 0xbb, 0x38, 0xd1, 0xe1, 0xd8, 0x5a, 0x13, 0xb0, 0x38, 0x1a, 0x42, 0xbe, 0x8b, 0x3e,
	0x89, 0xb8, 0x6c, 0xb9, 0x46, 0x47, 0x42, 0xa2, 0xdb, 0x30, 0xcf, 0x49, 0x24, 0x29, 0xb3, 0xc8,
	0x9c, 0xf1, 0x68, 0xea, 0xeb, 0xb0, 0xbf, 0x99, 0xc9, 0xda, 0xd9, 0xd7, 0x16, 0xfb, 0x21, 0x69,
	0xbb, 0x89, 0x79, 0xed, 0xc7, 0x5c, 0xfa, 0x86, 0xc7, 0x71, 0x38, 0x0a, 0x82, 0xdc, 0x2c, 0x20,
	0xc8, 0x64, 0x3e, 0x37, 0x9a, 0xf9, 0x09, 0xc8, 0xcb, 0xfb, 0x12, 0x03, 0x50, 0x4d, 0x64, 0x27,
	0x40, 0x7e, 0x64, 0x02, 0xc8, 0x81, 0x1b, 0x46, 0xac, 0x1b, 0x11, 0xce, 0x15, 0x0e, 0x4b, 0x6e,
	0x4a, 0x4b, 0xbc, 0x70, 0xfa, 0x31, 0x69, 0xb6, 0x06, 0x82, 0x70, 0x05, 0xb5, 0xbc, 0x5b, 0x92,
	0x9c, 0x1d, 0xc9, 0x90, 0xa6, 0xfa, 0x73, 0x67, 0xf8, 0x95, 0x95, 0xd0, 0x68, 0x05, 0xc0, 0x63,
	0x0f, 0x03, 0x23, 0x2d, 0x29, 0x69, 0x86, 0x23, 0x37, 0x07, 0xee, 0x63, 0xea, 0xe3, 0x96, 0xd9,
	0x79, 0x45, 0x77, 0xc8, 0xb0, 0x77, 0x01, 0x74, 0x0f, 0xd5, 0x40, 0xba, 0x3c, 0x3a, 0x90, 0x56,
	0x27, 0x35, 0x3e, 0x19, 0x45, 0x0f, 0x00, 0x0d, 0x27, 0xd1, 0x4b, 0x1b, 0x41, 0x8d, 0x5f, 0x2b,
	0xb0, 0xa0, 0x7d, 0xca, 0x86, 0xd3, 0x36, 0x41, 0x3f, 0x5b, 0xd9, 0x48, 0xc9, 0xcc, 0x43, 0x97,
	0x0e, 0x4f, 0xf4, 0xd0, 0x09, 0x59, 0x5b, 0x9f, 0x6e, 0xdc, 0x4a, 0x07, 0xf6, 0xde, 0xa7, 0xbf,
	0xff, 0xf5, 0x34, 0xb7, 0x85, 0x6e, 0xa8, 0x1f, 0x02, 0x5a, 0x51, 0xfd, 0x72, 0x49, 0x31, 0x59,
	0x7f, 0x6c, 0xb2, 0x76, 0xda, 0x2c, 0x10, 0x72, 0x81, 0x50, 0xef, 0x89, 0xd1, 0x0c, 0x93, 0x3c,
	0xbf, 0xb2, 0x60, 0xe9, 0x4d, 0x22, 0x46, 0x7e, 0x32, 0x9c, 0x3b, 0xbc, 0x28, 0x77, 0x76, 0x4d,
	0x49, 0x6a, 0x53, 0xae, 0x06, 0x7b, 0x5d, 0xe5, 0x79, 0x1e, 0xd9, 0x63, 0x79, 0x8e, 0xe6, 0x51,
	0x7f, 0x4c, 0xbd, 0x27, 0xe8, 0x07, 0x0b, 0xd0, 0x2d, 0x85, 0xf3, 0x91, 0x7c, 0xa6, 0x0c, 0x35,
	0x75, 0x4a, 0xb7, 0x54, 0x4a, 0x37, 0xec, 0x2b, 0x47, 0x94, 0x6e, 0x64, 0xe0, 0x8f, 0x57, 0xed,
	0x0d, 0x6b, 0x1d, 0x3d, 0xb5, 0x00, 0x3d, 0x08, 0xbd, 0xff, 0x3a, 0xd7, 0x0d, 0x95, 0xeb, 0xc5,
	0xc6, 0x14, 0xe5, 0x93, 0x59, 0x7d, 0x61, 0x01, 0xd2, 0x03, 0x79, 0xf6, 0x8e, 0x9e, 0x3d, 0x5c,
	0x69, 0xaf, 0x17, 0x8a, 0xb4, 0x95, 0xeb, 0xd3, 0xb4, 0xf2, 0x3b, 0x0b, 0xca, 0x99, 0x07, 0x88,
	0x5e, 0x9d, 0xe6, 0x3d, 0xa4, 0x0f, 0xe1, 0xfc, 0xa4, 0xea, 0xa8, 0x27, 0x70, 0x53, 0xe5, 0x73,
	0x05, 0x5d, 0x7e, 0xa1, 0x27, 0xc0, 0x51, 0x1f, 0x4a, 0x29, 0xf4, 0xa7, 0x2b, 0xd1, 0xc4, 0xf1,
	0x63, 0xdb, 0x2a, 0xa7, 0xd3, 0xa8, 0xf6, 0x8f, 0x35, 0xd2, 0xb5, 0xf9, 0xda, 0x82, 0x4a, 0x16,
	0xe6, 0x68, 0xa2, 0xdb, 0x29, 0x02, 0x5f, 0x53, 0x81, 0x5f, 0xb7, 0x5f, 0x9b, 0x15, 0xd4, 0x12,
	0x36, 0x03, 0xa8, 0x64, 0xb1, 0xfc, 0x52, 0x12, 0xba, 0xa0, 0x12, 0x3a, 0xdb, 0x38, 0xa2, 0x12,
	0x32, 0xf4, 0x27, 0x16, 0x2c, 0xb8, 0x84, 0x0b, 0x16, 0x91, 0x59, 0x3a, 0x31, 0x2d, 0x58, 0x6d,
	0xfb, 0xf0, 0xf0, 0xf5, 0x48, 0xc7, 0x45, 0x8f, 0xa0, 0x92, 0x7d, 0x34, 0x2f, 0x29, 0x03, 0x03,
	0x85, 0xf5, 0x23, 0x0a, 0xb0, 0x73, 0xfd, 0x97, 0x67, 0x2b, 0xd6, 0x6f, 0xcf, 0x56, 0xac, 0x3f,
	0x9e, 0xad, 0x58, 0xdf, 0xfc, 0xb9, 0xf2, 0xbf, 0xf7, 0xd7, 0x33, 0xff, 0x19, 0x4a, 0x02, 0x6c,
	0xf4, 0x70, 0x80, 0xbb, 0xc4, 0x93, 0x8e, 0xf8, 0xd0, 0x53, 0xab, 0xa0, 0x3e, 0x14, 0x2e, 0xfd,
	0x1d, 0x00, 0x00, 0xff, 0xff, 0xed, 0x69, 0x6f, 0xef, 0xdf, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackupServiceClient is the client API for BackupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackupServiceClient interface {
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment identified by the given context ID.
	ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error)
	// Fetch a backup policy by its id.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy
	GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy.
	CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy
	UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Delete a backup policy.
	// Note that the backup policy are initially only marked for deletion.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy
	DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment identified by the given context ID.
	ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error)
	// Fetch a backup by its id.
	// Required permissions:
	// - backup.backup.get on the backup policy
	GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error)
	// Create a new backup
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup.
	CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup
	UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Restore (or recover) a backup
	// Required permissions:
	// -  backup.backup.restore on the backup
	RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Delete a backup
	// Note that the backup are initially only marked for deletion.
	// Once all their dependent backup in the cloud are removed, the backup is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup
	DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
}

type backupServiceClient struct {
	cc *grpc.ClientConn
}

func NewBackupServiceClient(cc *grpc.ClientConn) BackupServiceClient {
	return &backupServiceClient{cc}
}

func (c *backupServiceClient) ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error) {
	out := new(BackupPolicyList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/ListBackupPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/GetBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/CreateBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/UpdateBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/DeleteBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error) {
	out := new(BackupList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/ListBackups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/GetBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/CreateBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/UpdateBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/RestoreBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/DeleteBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackupServiceServer is the server API for BackupService service.
type BackupServiceServer interface {
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment identified by the given context ID.
	ListBackupPolicies(context.Context, *ListBackupPoliciesRequest) (*BackupPolicyList, error)
	// Fetch a backup policy by its id.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy
	GetBackupPolicy(context.Context, *v1.IDOptions) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy.
	CreateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy
	UpdateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Delete a backup policy.
	// Note that the backup policy are initially only marked for deletion.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy
	DeleteBackupPolicy(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment identified by the given context ID.
	ListBackups(context.Context, *ListBackupsRequest) (*BackupList, error)
	// Fetch a backup by its id.
	// Required permissions:
	// - backup.backup.get on the backup policy
	GetBackup(context.Context, *v1.IDOptions) (*Backup, error)
	// Create a new backup
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup.
	CreateBackup(context.Context, *Backup) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup
	UpdateBackup(context.Context, *Backup) (*Backup, error)
	// Restore (or recover) a backup
	// Required permissions:
	// -  backup.backup.restore on the backup
	RestoreBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Delete a backup
	// Note that the backup are initially only marked for deletion.
	// Once all their dependent backup in the cloud are removed, the backup is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup
	DeleteBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
}

func RegisterBackupServiceServer(s *grpc.Server, srv BackupServiceServer) {
	s.RegisterService(&_BackupService_serviceDesc, srv)
}

func _BackupService_ListBackupPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/ListBackupPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, req.(*ListBackupPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/GetBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/CreateBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/UpdateBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/DeleteBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_ListBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/ListBackups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackups(ctx, req.(*ListBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/GetBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/CreateBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/UpdateBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_RestoreBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).RestoreBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/RestoreBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).RestoreBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/DeleteBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

var _BackupService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.backup.v1.BackupService",
	HandlerType: (*BackupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBackupPolicies",
			Handler:    _BackupService_ListBackupPolicies_Handler,
		},
		{
			MethodName: "GetBackupPolicy",
			Handler:    _BackupService_GetBackupPolicy_Handler,
		},
		{
			MethodName: "CreateBackupPolicy",
			Handler:    _BackupService_CreateBackupPolicy_Handler,
		},
		{
			MethodName: "UpdateBackupPolicy",
			Handler:    _BackupService_UpdateBackupPolicy_Handler,
		},
		{
			MethodName: "DeleteBackupPolicy",
			Handler:    _BackupService_DeleteBackupPolicy_Handler,
		},
		{
			MethodName: "ListBackups",
			Handler:    _BackupService_ListBackups_Handler,
		},
		{
			MethodName: "GetBackup",
			Handler:    _BackupService_GetBackup_Handler,
		},
		{
			MethodName: "CreateBackup",
			Handler:    _BackupService_CreateBackup_Handler,
		},
		{
			MethodName: "UpdateBackup",
			Handler:    _BackupService_UpdateBackup_Handler,
		},
		{
			MethodName: "RestoreBackup",
			Handler:    _BackupService_RestoreBackup_Handler,
		},
		{
			MethodName: "DeleteBackup",
			Handler:    _BackupService_DeleteBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "backup.proto",
}

func (m *BackupPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DeploymentId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.DeploymentId)))
		i += copy(dAtA[i:], m.DeploymentId)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DeletedAt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.DeletedAt.Size()))
		n2, err := m.DeletedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.IsDeleted {
		dAtA[i] = 0x38
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPaused {
		dAtA[i] = 0x40
		i++
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Schedule != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Schedule.Size()))
		n3, err := m.Schedule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Upload {
		dAtA[i] = 0x50
		i++
		if m.Upload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoDeleteAfter != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.AutoDeleteAfter.Size()))
		n4, err := m.AutoDeleteAfter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.EmailNotification) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.EmailNotification)))
		i += copy(dAtA[i:], m.EmailNotification)
	}
	if m.Status != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Status.Size()))
		n5, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicy_Schedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy_Schedule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ScheduleType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.ScheduleType)))
		i += copy(dAtA[i:], m.ScheduleType)
	}
	if m.ScheduleHourly != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleHourly.Size()))
		n6, err := m.ScheduleHourly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ScheduleDaily != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleDaily.Size()))
		n7, err := m.ScheduleDaily.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ScheduleMonthly != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleMonthly.Size()))
		n8, err := m.ScheduleMonthly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.CronSchedule) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.CronSchedule)))
		i += copy(dAtA[i:], m.CronSchedule)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicy_Schedule_HourlySchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy_Schedule_HourlySchedule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ScheduleEveryIntervalHours != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleEveryIntervalHours))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicy_Schedule_DailySchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy_Schedule_DailySchedule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Monday {
		dAtA[i] = 0x8
		i++
		if m.Monday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tuesday {
		dAtA[i] = 0x10
		i++
		if m.Tuesday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Wednesday {
		dAtA[i] = 0x18
		i++
		if m.Wednesday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Thursday {
		dAtA[i] = 0x20
		i++
		if m.Thursday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Friday {
		dAtA[i] = 0x28
		i++
		if m.Friday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Saturday {
		dAtA[i] = 0x30
		i++
		if m.Saturday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Sunday {
		dAtA[i] = 0x38
		i++
		if m.Sunday {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ScheduleAt != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleAt.Size()))
		n9, err := m.ScheduleAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicy_Schedule_MonthlySchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy_Schedule_MonthlySchedule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.First {
		dAtA[i] = 0x8
		i++
		if m.First {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Last {
		dAtA[i] = 0x10
		i++
		if m.Last {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DayOfMonth != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.DayOfMonth))
	}
	if m.ScheduleAt != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.ScheduleAt.Size()))
		n10, err := m.ScheduleAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicy_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicy_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NextBackup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.NextBackup.Size()))
		n11, err := m.NextBackup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBackup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBackupPoliciesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBackupPoliciesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Options.Size()))
		n12, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.IncludeDeleted {
		dAtA[i] = 0x10
		i++
		if m.IncludeDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Backup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.DeploymentId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.DeploymentId)))
		i += copy(dAtA[i:], m.DeploymentId)
	}
	if len(m.BackupPolicyId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.BackupPolicyId)))
		i += copy(dAtA[i:], m.BackupPolicyId)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.CreatedAt.Size()))
		n13, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.DeletedAt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.DeletedAt.Size()))
		n14, err := m.DeletedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.IsDeleted {
		dAtA[i] = 0x40
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoDeletedAt != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.AutoDeletedAt.Size()))
		n15, err := m.AutoDeletedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.DeploymentInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.DeploymentInfo.Size()))
		n16, err := m.DeploymentInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Status != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Status.Size()))
		n17, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Backup_DeploymentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backup_DeploymentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Servers != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Servers.Size()))
		n18, err := m.Servers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Backup_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backup_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.CreatedAt.Size()))
		n19, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Progress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBackup(dAtA, i, uint64(len(m.Progress)))
		i += copy(dAtA[i:], m.Progress)
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.SizeBytes))
	}
	if m.Uploaded {
		dAtA[i] = 0x40
		i++
		if m.Uploaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Downloaded {
		dAtA[i] = 0x48
		i++
		if m.Downloaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Available {
		dAtA[i] = 0x50
		i++
		if m.Available {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBackup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBackupsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBackupsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBackup(dAtA, i, uint64(m.Options.Size()))
		n20, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBackup(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BackupPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.IsPaused {
		n += 2
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Upload {
		n += 2
	}
	if m.AutoDeleteAfter != nil {
		l = m.AutoDeleteAfter.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.EmailNotification)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicy_Schedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScheduleType)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.ScheduleHourly != nil {
		l = m.ScheduleHourly.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.ScheduleDaily != nil {
		l = m.ScheduleDaily.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.ScheduleMonthly != nil {
		l = m.ScheduleMonthly.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.CronSchedule)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicy_Schedule_HourlySchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScheduleEveryIntervalHours != 0 {
		n += 1 + sovBackup(uint64(m.ScheduleEveryIntervalHours))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicy_Schedule_DailySchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monday {
		n += 2
	}
	if m.Tuesday {
		n += 2
	}
	if m.Wednesday {
		n += 2
	}
	if m.Thursday {
		n += 2
	}
	if m.Friday {
		n += 2
	}
	if m.Saturday {
		n += 2
	}
	if m.Sunday {
		n += 2
	}
	if m.ScheduleAt != nil {
		l = m.ScheduleAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicy_Schedule_MonthlySchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.First {
		n += 2
	}
	if m.Last {
		n += 2
	}
	if m.DayOfMonth != 0 {
		n += 1 + sovBackup(uint64(m.DayOfMonth))
	}
	if m.ScheduleAt != nil {
		l = m.ScheduleAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicy_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextBackup != nil {
		l = m.NextBackup.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupPolicyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBackup(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBackupPoliciesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.IncludeDeleted {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.BackupPolicyId)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.AutoDeletedAt != nil {
		l = m.AutoDeletedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.DeploymentInfo != nil {
		l = m.DeploymentInfo.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Backup_DeploymentInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.Servers != nil {
		l = m.Servers.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Backup_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	l = len(m.Progress)
	if l > 0 {
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovBackup(uint64(m.SizeBytes))
	}
	if m.Uploaded {
		n += 2
	}
	if m.Downloaded {
		n += 2
	}
	if m.Available {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBackup(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBackupsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovBackup(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBackup(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBackup(x uint64) (n int) {
	return sovBackup(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackupPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &BackupPolicy_Schedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upload = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeleteAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeleteAfter == nil {
				m.AutoDeleteAfter = &types.Duration{}
			}
			if err := m.AutoDeleteAfter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailNotification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailNotification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BackupPolicy_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicy_Schedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScheduleType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleHourly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleHourly == nil {
				m.ScheduleHourly = &BackupPolicy_Schedule_HourlySchedule{}
			}
			if err := m.ScheduleHourly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleDaily", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleDaily == nil {
				m.ScheduleDaily = &BackupPolicy_Schedule_DailySchedule{}
			}
			if err := m.ScheduleDaily.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleMonthly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleMonthly == nil {
				m.ScheduleMonthly = &BackupPolicy_Schedule_MonthlySchedule{}
			}
			if err := m.ScheduleMonthly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronSchedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronSchedule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicy_Schedule_HourlySchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HourlySchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HourlySchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleEveryIntervalHours", wireType)
			}
			m.ScheduleEveryIntervalHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduleEveryIntervalHours |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicy_Schedule_DailySchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailySchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailySchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Monday = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tuesday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tuesday = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wednesday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wednesday = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thursday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Thursday = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Friday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Friday = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Saturday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Saturday = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunday", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sunday = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleAt == nil {
				m.ScheduleAt = &types.Timestamp{}
			}
			if err := m.ScheduleAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicy_Schedule_MonthlySchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonthlySchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonthlySchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.First = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Last = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfMonth", wireType)
			}
			m.DayOfMonth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayOfMonth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScheduleAt == nil {
				m.ScheduleAt = &types.Timestamp{}
			}
			if err := m.ScheduleAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicy_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBackup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextBackup == nil {
				m.NextBackup = &types.Timestamp{}
			}
			if err := m.NextBackup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &BackupPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBackupPoliciesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBackupPoliciesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBackupPoliciesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Backup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Backup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Backup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupPolicyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupPolicyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletedAt == nil {
				m.AutoDeletedAt = &types.Timestamp{}
			}
			if err := m.AutoDeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentInfo == nil {
				m.DeploymentInfo = &Backup_DeploymentInfo{}
			}
			if err := m.DeploymentInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Backup_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Backup_DeploymentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Servers == nil {
				m.Servers = &v11.Deployment_ServersSpec{}
			}
			if err := m.Servers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Backup_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Progress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uploaded = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downloaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Downloaded = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Available = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Backup{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBackupsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBackupsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBackupsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBackup
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBackup
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBackup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBackup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBackup(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBackup
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBackup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBackup
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBackup
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBackup
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBackup(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBackup
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBackup = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBackup   = fmt.Errorf("proto: integer overflow")
)
