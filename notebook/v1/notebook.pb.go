// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: notebook.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// List of Notebooks.
type NotebookList struct {
	Items                []*Notebook `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NotebookList) Reset()         { *m = NotebookList{} }
func (m *NotebookList) String() string { return proto.CompactTextString(m) }
func (*NotebookList) ProtoMessage()    {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{0}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookList) GetItems() []*Notebook {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request for listing notebooks.
type ListNotebookRequest struct {
	// List notebooks for this deployment ID.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Optional common list options, the context_id is ignored
	Options              *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListNotebookRequest) Reset()         { *m = ListNotebookRequest{} }
func (m *ListNotebookRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebookRequest) ProtoMessage()    {}
func (*ListNotebookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{1}
}
func (m *ListNotebookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebookRequest.Merge(m, src)
}
func (m *ListNotebookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebookRequest proto.InternalMessageInfo

func (m *ListNotebookRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *ListNotebookRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Request for creating a notebook.
type CreateNotebookRequest struct {
	// ID of the Deployment this notebook belongs to.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Configuration of the notebook instance.
	Spec                 *Spec    `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateNotebookRequest) Reset()         { *m = CreateNotebookRequest{} }
func (m *CreateNotebookRequest) String() string { return proto.CompactTextString(m) }
func (*CreateNotebookRequest) ProtoMessage()    {}
func (*CreateNotebookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{2}
}
func (m *CreateNotebookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateNotebookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateNotebookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateNotebookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNotebookRequest.Merge(m, src)
}
func (m *CreateNotebookRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateNotebookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNotebookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNotebookRequest proto.InternalMessageInfo

func (m *CreateNotebookRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *CreateNotebookRequest) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Contains the specification and status of a given notebook instance.
type Notebook struct {
	// ID of the Notebook.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the Deployment this notebook belongs to.
	DeploymentId string `protobuf:"bytes,2,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Set if the notebook should be stopped.
	Stopped bool `protobuf:"varint,3,opt,name=stopped,proto3" json:"stopped,omitempty"`
	// Identifier of the entity responsible for stopping the notebook.
	StoppedBy string `protobuf:"bytes,4,opt,name=stopped_by,json=stoppedBy,proto3" json:"stopped_by,omitempty"`
	// Set if the notebook should be paused.
	Paused bool `protobuf:"varint,5,opt,name=paused,proto3" json:"paused,omitempty"`
	// Identifier of the entity responsible for pausing the notebook.
	PausedBy string `protobuf:"bytes,6,opt,name=paused_by,json=pausedBy,proto3" json:"paused_by,omitempty"`
	// Configuration of the notebook instance.
	Spec *Spec `protobuf:"bytes,7,opt,name=spec,proto3" json:"spec,omitempty"`
	// Status of the notebook.
	// Note: all fields in this block are read-only.
	Status               *Status  `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notebook) Reset()         { *m = Notebook{} }
func (m *Notebook) String() string { return proto.CompactTextString(m) }
func (*Notebook) ProtoMessage()    {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{3}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notebook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *Notebook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notebook) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Notebook) GetStopped() bool {
	if m != nil {
		return m.Stopped
	}
	return false
}

func (m *Notebook) GetStoppedBy() string {
	if m != nil {
		return m.StoppedBy
	}
	return ""
}

func (m *Notebook) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *Notebook) GetPausedBy() string {
	if m != nil {
		return m.PausedBy
	}
	return ""
}

func (m *Notebook) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Notebook) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Specification options for a notebook.
type Spec struct {
	// Number of CPU units required by the notebook instance.
	CPU int32 `protobuf:"varint,1,opt,name=CPU,proto3" json:"CPU,omitempty"`
	// Memory required by the notebook instance.
	// Should be expressed as power-of-two: Mi, Gi, Ti, Pi, etc.
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// Disk space required by the notebook instance.
	// Should be expressed as power-of-two: Mi, Gi, Ti, Pi, etc.
	Disk                 string   `protobuf:"bytes,3,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spec) Reset()         { *m = Spec{} }
func (m *Spec) String() string { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()    {}
func (*Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{4}
}
func (m *Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spec.Merge(m, src)
}
func (m *Spec) XXX_Size() int {
	return m.Size()
}
func (m *Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Spec proto.InternalMessageInfo

func (m *Spec) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *Spec) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *Spec) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

// Contains details for the current state of the notebook.
type Condition struct {
	// Type of condition being reported.
	// Should be one of the following:
	// - Running
	// - Paused
	// - Stopped
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Status of the condition, one of true or false.
	Status bool `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// Identifier of the entity responsible for the conditions's last transition.
	TriggeredBy string `protobuf:"bytes,3,opt,name=triggered_by,json=triggeredBy,proto3" json:"triggered_by,omitempty"`
	// Reason for the condition's last transition.
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// The last time the condition transitioned from one status to another.
	LastTransitionTime   *types.Timestamp `protobuf:"bytes,5,opt,name=last_transition_time,json=lastTransitionTime,proto3" json:"last_transition_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{5}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Condition) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *Condition) GetTriggeredBy() string {
	if m != nil {
		return m.TriggeredBy
	}
	return ""
}

func (m *Condition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Condition) GetLastTransitionTime() *types.Timestamp {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

// Status of the notebook.
// Note: all fields in this block are read-only.
type Status struct {
	// Contains details for the current state of the notebook.
	Conditions           []*Condition `protobuf:"bytes,1,rep,name=conditions,proto3" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{6}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func init() {
	proto.RegisterType((*NotebookList)(nil), "arangodb.cloud.notebook.v1.NotebookList")
	proto.RegisterType((*ListNotebookRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebookRequest")
	proto.RegisterType((*CreateNotebookRequest)(nil), "arangodb.cloud.notebook.v1.CreateNotebookRequest")
	proto.RegisterType((*Notebook)(nil), "arangodb.cloud.notebook.v1.Notebook")
	proto.RegisterType((*Spec)(nil), "arangodb.cloud.notebook.v1.Spec")
	proto.RegisterType((*Condition)(nil), "arangodb.cloud.notebook.v1.Condition")
	proto.RegisterType((*Status)(nil), "arangodb.cloud.notebook.v1.Status")
}

func init() { proto.RegisterFile("notebook.proto", fileDescriptor_e4288154b4c2ba34) }

var fileDescriptor_e4288154b4c2ba34 = []byte{
	// 812 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x4d, 0x6f, 0xeb, 0x44,
	0x14, 0x65, 0xd2, 0x34, 0x69, 0x6e, 0x3e, 0x40, 0x03, 0x3c, 0x19, 0xf3, 0xc8, 0xcb, 0x73, 0x9b,
	0xa7, 0xa8, 0xbc, 0x67, 0x2b, 0x81, 0x55, 0x90, 0x40, 0xb4, 0x7d, 0xaa, 0x8a, 0x2a, 0x5a, 0xb9,
	0x85, 0x05, 0x9b, 0x68, 0x12, 0x0f, 0xc6, 0x6a, 0xec, 0x31, 0x9e, 0x49, 0x24, 0xab, 0x02, 0xf1,
	0xb1, 0x63, 0x87, 0xd8, 0xb0, 0xe3, 0x7f, 0xb0, 0x62, 0xc9, 0x12, 0x89, 0x3f, 0x80, 0x0a, 0x3f,
	0x04, 0xcd, 0x78, 0xec, 0x06, 0xda, 0x24, 0x05, 0x75, 0x77, 0xe7, 0xe3, 0xdc, 0x73, 0xee, 0xf1,
	0xdc, 0x6b, 0x68, 0x45, 0x4c, 0xd0, 0x31, 0x63, 0x17, 0x76, 0x9c, 0x30, 0xc1, 0xb0, 0x49, 0x12,
	0x12, 0xf9, 0xcc, 0x1b, 0xdb, 0x93, 0x29, 0x9b, 0x79, 0x76, 0x71, 0x3c, 0xef, 0x9b, 0x0f, 0x26,
	0x2c, 0x0c, 0x59, 0xe4, 0xcc, 0xfb, 0x4e, 0x16, 0x65, 0x18, 0xf3, 0x1d, 0x3f, 0x10, 0x9f, 0xcd,
	0xc6, 0xf6, 0x84, 0x85, 0x8e, 0xcf, 0xa6, 0x24, 0xf2, 0x1d, 0x75, 0x30, 0x9e, 0x7d, 0xea, 0xc4,
	0x22, 0x8d, 0x29, 0x77, 0x44, 0x10, 0x52, 0x2e, 0x48, 0x18, 0x5f, 0x47, 0x1a, 0xfc, 0xd0, 0x67,
	0xcc, 0x9f, 0x52, 0x87, 0xc4, 0x81, 0x43, 0xa2, 0x88, 0x09, 0x22, 0x02, 0x16, 0xf1, 0xec, 0xd4,
	0xfa, 0x00, 0x1a, 0x1f, 0x6a, 0x05, 0xc7, 0x01, 0x17, 0x78, 0x08, 0x9b, 0x81, 0xa0, 0x21, 0x37,
	0x50, 0x67, 0xa3, 0x57, 0x1f, 0xec, 0xd8, 0xcb, 0xe5, 0xda, 0x39, 0xd0, 0xcd, 0x20, 0xd6, 0x25,
	0xbc, 0x2c, 0x73, 0x14, 0xdb, 0xf4, 0xf3, 0x19, 0xe5, 0x02, 0x6f, 0x43, 0xd3, 0xa3, 0xf1, 0x94,
	0xa5, 0x21, 0x8d, 0xc4, 0x28, 0xf0, 0x0c, 0xd4, 0x41, 0xbd, 0x9a, 0xdb, 0xb8, 0xde, 0x3c, 0xf2,
	0xf0, 0x7b, 0x50, 0x65, 0xb1, 0x12, 0x66, 0x40, 0x07, 0xf5, 0xea, 0x83, 0xee, 0xbf, 0x99, 0xb5,
	0x23, 0xf3, 0xbe, 0x2d, 0x49, 0x4e, 0xb2, 0xcb, 0x6e, 0x8e, 0xb2, 0x12, 0x78, 0x75, 0x3f, 0xa1,
	0x44, 0xd0, 0xff, 0x45, 0xff, 0x36, 0x94, 0x79, 0x4c, 0x27, 0x46, 0x49, 0x71, 0x77, 0x56, 0x55,
	0x7d, 0x16, 0xd3, 0x89, 0xab, 0x6e, 0x5b, 0x3f, 0x95, 0x60, 0x2b, 0xa7, 0xc3, 0x2d, 0x28, 0x15,
	0xc9, 0x4b, 0x81, 0x77, 0x93, 0xb7, 0x74, 0x0b, 0xaf, 0x01, 0x55, 0x2e, 0x58, 0x1c, 0x53, 0xcf,
	0xd8, 0xe8, 0xa0, 0xde, 0x96, 0x9b, 0x2f, 0xf1, 0x1b, 0x00, 0x3a, 0x1c, 0x8d, 0x53, 0xa3, 0xac,
	0xb0, 0x35, 0xbd, 0xb3, 0x97, 0xe2, 0x07, 0x50, 0x89, 0xc9, 0x8c, 0x53, 0xcf, 0xd8, 0x54, 0x38,
	0xbd, 0xc2, 0xaf, 0x43, 0x2d, 0x8b, 0x24, 0xaa, 0xa2, 0x50, 0x5b, 0xd9, 0xc6, 0x5e, 0x5a, 0x54,
	0x59, 0xfd, 0x2f, 0x55, 0xe2, 0x21, 0x54, 0xb8, 0x20, 0x62, 0x96, 0x7f, 0x19, 0x6b, 0x25, 0x4e,
	0xdd, 0x74, 0x35, 0xc2, 0x3a, 0x80, 0xb2, 0xcc, 0x84, 0x5f, 0x82, 0x8d, 0xfd, 0xd3, 0x8f, 0x94,
	0x3b, 0x9b, 0xae, 0x0c, 0x65, 0x01, 0x21, 0x0d, 0x59, 0x92, 0x6a, 0x5f, 0xf4, 0x0a, 0x63, 0x28,
	0x7b, 0x01, 0xbf, 0x50, 0x76, 0xd4, 0x5c, 0x15, 0x5b, 0xbf, 0x20, 0xa8, 0xed, 0xb3, 0xc8, 0x0b,
	0xe4, 0xa7, 0x96, 0x37, 0xe4, 0x9b, 0xd7, 0x56, 0xab, 0x58, 0x66, 0xd3, 0x1a, 0x4b, 0x99, 0x1d,
	0xd9, 0x0a, 0x3f, 0x86, 0x86, 0x48, 0x02, 0xdf, 0xa7, 0x49, 0xe6, 0x48, 0x96, 0xb5, 0x5e, 0xec,
	0x65, 0x4e, 0x26, 0x94, 0x70, 0x16, 0x69, 0x93, 0xf5, 0x0a, 0x1f, 0xc3, 0x2b, 0x53, 0xc2, 0xc5,
	0x48, 0x24, 0x24, 0xe2, 0x8a, 0x79, 0x24, 0x5b, 0x4b, 0xf9, 0x5d, 0x1f, 0x98, 0x76, 0xd6, 0x56,
	0x76, 0xde, 0x88, 0xf6, 0x79, 0xde, 0x77, 0x2e, 0x96, 0xb8, 0xf3, 0x02, 0x26, 0x0f, 0xac, 0x13,
	0xa8, 0x64, 0xd6, 0xe0, 0xe7, 0x00, 0x93, 0xbc, 0x96, 0xbc, 0xcd, 0xba, 0xab, 0x2c, 0x2d, 0x2a,
	0x77, 0x17, 0x80, 0x83, 0x9f, 0xab, 0xf0, 0x62, 0xfe, 0xf6, 0xce, 0x68, 0x32, 0x0f, 0x26, 0x14,
	0xa7, 0xd0, 0x3c, 0xa4, 0xe2, 0xfd, 0xd3, 0xa3, 0x8f, 0x69, 0xc2, 0xa5, 0x55, 0x8f, 0x96, 0x37,
	0xd1, 0xf3, 0x30, 0x16, 0xa9, 0xf9, 0x78, 0xf9, 0x05, 0x9d, 0xc3, 0xda, 0xf9, 0xe6, 0xf7, 0xbf,
	0x7e, 0x28, 0xb5, 0xf1, 0x43, 0x35, 0x41, 0x72, 0x61, 0x72, 0x46, 0x91, 0x38, 0x78, 0x36, 0xd7,
	0x4c, 0x5f, 0x21, 0xa8, 0x1f, 0xd2, 0xa2, 0xf7, 0xf1, 0xf6, 0xf2, 0xc4, 0x47, 0x07, 0xba, 0x79,
	0xcd, 0x3b, 0x4d, 0x17, 0xeb, 0x89, 0x12, 0xd0, 0xc1, 0xed, 0x1b, 0x02, 0x8a, 0xf8, 0x32, 0xf0,
	0xbe, 0xc0, 0xdf, 0x21, 0x68, 0xfd, 0x73, 0x04, 0xe0, 0xfe, 0x4a, 0x5f, 0x6f, 0x1b, 0x17, 0xe6,
	0x3a, 0xcb, 0x72, 0x3f, 0xcc, 0xd7, 0x96, 0xca, 0x19, 0xa2, 0x5d, 0xfc, 0x25, 0xb4, 0x0e, 0xe8,
	0x94, 0x2e, 0x68, 0xb9, 0x93, 0x23, 0x6b, 0xd9, 0xb5, 0x19, 0xbb, 0xeb, 0xcc, 0xf8, 0x1a, 0x41,
	0xe3, 0x4c, 0xb0, 0xf8, 0x9e, 0xe9, 0xdf, 0x54, 0xf4, 0x5d, 0x6b, 0x7b, 0x35, 0xbd, 0x23, 0x07,
	0x15, 0xfe, 0x16, 0x41, 0xf3, 0x54, 0xce, 0x9e, 0x7b, 0x16, 0xf1, 0x54, 0x89, 0x78, 0x62, 0xed,
	0xac, 0x11, 0xa1, 0xe6, 0x1e, 0xfe, 0x1e, 0x41, 0x73, 0xf1, 0xb7, 0xc4, 0xb1, 0xb3, 0xea, 0x55,
	0xdc, 0xf2, 0x07, 0x33, 0x7b, 0x77, 0x79, 0xa7, 0x12, 0x68, 0x75, 0x95, 0xb4, 0x47, 0x96, 0xb9,
	0x54, 0x1a, 0x1f, 0xa2, 0xdd, 0xbd, 0x77, 0x7f, 0xbd, 0x6a, 0xa3, 0xdf, 0xae, 0xda, 0xe8, 0x8f,
	0xab, 0x36, 0xfa, 0xf1, 0xcf, 0xf6, 0x0b, 0x9f, 0x3c, 0x5d, 0xf8, 0xc5, 0xe7, 0x64, 0xcf, 0x42,
	0x12, 0x11, 0x9f, 0x7a, 0x32, 0x17, 0x5f, 0x4c, 0x36, 0xae, 0xa8, 0xa9, 0xf3, 0xd6, 0xdf, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x25, 0x44, 0x03, 0x4c, 0x5d, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NotebookServiceClient is the client API for NotebookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotebookServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(ctx context.Context, in *CreateNotebookRequest, opts ...grpc.CallOption) (*v1.Empty, error)
	// Delete an existing notebook using its ID.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Stop a running notebook.
	// Required permissions:
	// - notebook.notebook.stop
	StopNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Pause a running notebook.
	// Required permissions:
	// - notebook.notebook.pause
	PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// List all notebooks for a deployment.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error)
}

type notebookServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotebookServiceClient(cc *grpc.ClientConn) NotebookServiceClient {
	return &notebookServiceClient{cc}
}

func (c *notebookServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) CreateNotebook(ctx context.Context, in *CreateNotebookRequest, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) StopNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/StopNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error) {
	out := new(NotebookList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotebookServiceServer is the server API for NotebookService service.
type NotebookServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(context.Context, *v1.IDOptions) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(context.Context, *CreateNotebookRequest) (*v1.Empty, error)
	// Delete an existing notebook using its ID.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Stop a running notebook.
	// Required permissions:
	// - notebook.notebook.stop
	StopNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Pause a running notebook.
	// Required permissions:
	// - notebook.notebook.pause
	PauseNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// List all notebooks for a deployment.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(context.Context, *ListNotebookRequest) (*NotebookList, error)
}

// UnimplementedNotebookServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNotebookServiceServer struct {
}

func (*UnimplementedNotebookServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedNotebookServiceServer) GetNotebook(ctx context.Context, req *v1.IDOptions) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) CreateNotebook(ctx context.Context, req *CreateNotebookRequest) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) DeleteNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) StopNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) PauseNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebooks(ctx context.Context, req *ListNotebookRequest) (*NotebookList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebooks not implemented")
}

func RegisterNotebookServiceServer(s *grpc.Server, srv NotebookServiceServer) {
	s.RegisterService(&_NotebookService_serviceDesc, srv)
}

func _NotebookService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_GetNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_CreateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, req.(*CreateNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_DeleteNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_StopNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).StopNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/StopNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).StopNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_PauseNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, req.(*ListNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotebookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.notebook.v1.NotebookService",
	HandlerType: (*NotebookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _NotebookService_GetAPIVersion_Handler,
		},
		{
			MethodName: "GetNotebook",
			Handler:    _NotebookService_GetNotebook_Handler,
		},
		{
			MethodName: "CreateNotebook",
			Handler:    _NotebookService_CreateNotebook_Handler,
		},
		{
			MethodName: "DeleteNotebook",
			Handler:    _NotebookService_DeleteNotebook_Handler,
		},
		{
			MethodName: "StopNotebook",
			Handler:    _NotebookService_StopNotebook_Handler,
		},
		{
			MethodName: "PauseNotebook",
			Handler:    _NotebookService_PauseNotebook_Handler,
		},
		{
			MethodName: "ListNotebooks",
			Handler:    _NotebookService_ListNotebooks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notebook.proto",
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateNotebookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNotebookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateNotebookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PausedBy) > 0 {
		i -= len(m.PausedBy)
		copy(dAtA[i:], m.PausedBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.PausedBy)))
		i--
		dAtA[i] = 0x32
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.StoppedBy) > 0 {
		i -= len(m.StoppedBy)
		copy(dAtA[i:], m.StoppedBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.StoppedBy)))
		i--
		dAtA[i] = 0x22
	}
	if m.Stopped {
		i--
		if m.Stopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Disk) > 0 {
		i -= len(m.Disk)
		copy(dAtA[i:], m.Disk)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Disk)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memory) > 0 {
		i -= len(m.Memory)
		copy(dAtA[i:], m.Memory)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Memory)))
		i--
		dAtA[i] = 0x12
	}
	if m.CPU != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.CPU))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TriggeredBy) > 0 {
		i -= len(m.TriggeredBy)
		copy(dAtA[i:], m.TriggeredBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.TriggeredBy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotebook(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotebook(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateNotebookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Stopped {
		n += 2
	}
	l = len(m.StoppedBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	l = len(m.PausedBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CPU != 0 {
		n += 1 + sovNotebook(uint64(m.CPU))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Disk)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status {
		n += 2
	}
	l = len(m.TriggeredBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotebook(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotebook(x uint64) (n int) {
	return sovNotebook(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNotebookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNotebookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNotebookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stopped = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoppedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoppedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			m.CPU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CPU |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &types.Timestamp{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotebook(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotebook
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotebook
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotebook
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotebook        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotebook          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotebook = fmt.Errorf("proto: unexpected end of group")
)
