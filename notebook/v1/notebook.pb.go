// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: notebook.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	v11 "github.com/arangodb-managed/apis/data/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// List of Notebooks.
type NotebookList struct {
	Items                []*Notebook `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NotebookList) Reset()         { *m = NotebookList{} }
func (m *NotebookList) String() string { return proto.CompactTextString(m) }
func (*NotebookList) ProtoMessage()    {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{0}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookList) GetItems() []*Notebook {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request for listing notebooks.
type ListNotebookRequest struct {
	// List notebooks for this deployment ID.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Optional common list options, the context_id is ignored
	Options              *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListNotebookRequest) Reset()         { *m = ListNotebookRequest{} }
func (m *ListNotebookRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebookRequest) ProtoMessage()    {}
func (*ListNotebookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{1}
}
func (m *ListNotebookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebookRequest.Merge(m, src)
}
func (m *ListNotebookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebookRequest proto.InternalMessageInfo

func (m *ListNotebookRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *ListNotebookRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Contains the specification and status of a given notebook instance.
type Notebook struct {
	// ID of the Notebook.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the Deployment this notebook belongs to.
	// Read-only after creation.
	DeploymentId string `protobuf:"bytes,2,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// URL of the Notebook.
	// This is a read-only value.
	Url string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the notebook.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the notebook.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// If the notebook should be paused.
	IsPaused bool `protobuf:"varint,6,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// Identifier of the user that created this notebook.
	// Read-only after creation.
	CreatedById string `protobuf:"bytes,7,opt,name=created_by_id,json=createdById,proto3" json:"created_by_id,omitempty"`
	// Time at which this notebook was created.
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Model specification for the notebook.
	// Read-only after creation.
	Model *ModelSpec `protobuf:"bytes,9,opt,name=model,proto3" json:"model,omitempty"`
	// If the notebook should be deleted.
	IsDeleted bool `protobuf:"varint,10,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Time at which this notebook was deleted.
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,11,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Status of the notebook. Represents the state of the notebook as observed by the controller.
	// This is a read-only value.
	Status               *Status  `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notebook) Reset()         { *m = Notebook{} }
func (m *Notebook) String() string { return proto.CompactTextString(m) }
func (*Notebook) ProtoMessage()    {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{2}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notebook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *Notebook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notebook) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Notebook) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Notebook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Notebook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Notebook) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

func (m *Notebook) GetCreatedById() string {
	if m != nil {
		return m.CreatedById
	}
	return ""
}

func (m *Notebook) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Notebook) GetModel() *ModelSpec {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *Notebook) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *Notebook) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Notebook) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Model specification for the notebook.
type ModelSpec struct {
	// Type of model being used.
	// This should refer to the `id` of a `NotebookModel` object.
	NotebookModel string `protobuf:"bytes,1,opt,name=notebook_model,json=notebookModel,proto3" json:"notebook_model,omitempty"`
	// Disk size allocated to the notebook instance (in GiB).
	DiskSize             string   `protobuf:"bytes,2,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelSpec) Reset()         { *m = ModelSpec{} }
func (m *ModelSpec) String() string { return proto.CompactTextString(m) }
func (*ModelSpec) ProtoMessage()    {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{3}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelSpec) GetNotebookModel() string {
	if m != nil {
		return m.NotebookModel
	}
	return ""
}

func (m *ModelSpec) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

// Specifies the resource configuration for a notebook.
type NotebookModel struct {
	// System identifier of the model.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable name of the model.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// CPU units allocated to the notebook.
	// 1 CPU unit equals 1 physical / virtual CPU.
	Cpu int32 `protobuf:"varint,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// Memory allocated to the notebook in 'GiB'.
	Memory               int32    `protobuf:"varint,4,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotebookModel) Reset()         { *m = NotebookModel{} }
func (m *NotebookModel) String() string { return proto.CompactTextString(m) }
func (*NotebookModel) ProtoMessage()    {}
func (*NotebookModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{4}
}
func (m *NotebookModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookModel.Merge(m, src)
}
func (m *NotebookModel) XXX_Size() int {
	return m.Size()
}
func (m *NotebookModel) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookModel.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookModel proto.InternalMessageInfo

func (m *NotebookModel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NotebookModel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NotebookModel) GetCpu() int32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *NotebookModel) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

// List of notebook models.
type NotebookModelList struct {
	Items                []*NotebookModel `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NotebookModelList) Reset()         { *m = NotebookModelList{} }
func (m *NotebookModelList) String() string { return proto.CompactTextString(m) }
func (*NotebookModelList) ProtoMessage()    {}
func (*NotebookModelList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{5}
}
func (m *NotebookModelList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookModelList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookModelList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookModelList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookModelList.Merge(m, src)
}
func (m *NotebookModelList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookModelList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookModelList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookModelList proto.InternalMessageInfo

func (m *NotebookModelList) GetItems() []*NotebookModel {
	if m != nil {
		return m.Items
	}
	return nil
}

// Requet for listing notebook models.
type ListNotebookModelRequest struct {
	// ID of the deployment that the notebook belongs to.
	DeploymentId         string   `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListNotebookModelRequest) Reset()         { *m = ListNotebookModelRequest{} }
func (m *ListNotebookModelRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebookModelRequest) ProtoMessage()    {}
func (*ListNotebookModelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{6}
}
func (m *ListNotebookModelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebookModelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebookModelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebookModelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebookModelRequest.Merge(m, src)
}
func (m *ListNotebookModelRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebookModelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebookModelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebookModelRequest proto.InternalMessageInfo

func (m *ListNotebookModelRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

// Status of the notebook. Represents the state of the notebook as observed by the controller.
// Note: all fields in this block are read-only.
type Status struct {
	// Where the notebook is in its lifecycle at any given time.
	// Should contain only one of the following values:
	// "Initialising"   - Notebook is initialising.
	// "Running"        - Notebook is running.
	// "Hibernating"    - Notebook is moving to a hibernated state.
	// "Hibernated"     - Notebook has moved to a hibernated state.
	// "Error"          - Notebook is in an errored state. Additional information can be obtained from `message` field.
	Phase string `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	// Supporting information about the notebook phase - such as error messages in case of failures.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// The last time this notebook was updated.
	LastUpdatedAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Resource usage of the notebook.
	Usage                *Status_Usage `protobuf:"bytes,10,opt,name=usage,proto3" json:"usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{7}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

func (m *Status) GetUsage() *Status_Usage {
	if m != nil {
		return m.Usage
	}
	return nil
}

// Resource usage of the notebook.
type Status_Usage struct {
	// Information about the data volume used to store the data
	DataVolumeInfo *v11.DataVolumeInfo `protobuf:"bytes,20,opt,name=data_volume_info,json=dataVolumeInfo,proto3" json:"data_volume_info,omitempty"`
	// Last known memory usage in bytes
	LastMemoryUsage int64 `protobuf:"varint,31,opt,name=last_memory_usage,json=lastMemoryUsage,proto3" json:"last_memory_usage,omitempty"`
	// Last known CPU usage in vCPU units
	LastCpuUsage float32 `protobuf:"fixed32,32,opt,name=last_cpu_usage,json=lastCpuUsage,proto3" json:"last_cpu_usage,omitempty"`
	// Last known memory limit in bytes
	LastMemoryLimit int64 `protobuf:"varint,33,opt,name=last_memory_limit,json=lastMemoryLimit,proto3" json:"last_memory_limit,omitempty"`
	// Last known CPU limit in vCPU units
	LastCpuLimit         float32  `protobuf:"fixed32,34,opt,name=last_cpu_limit,json=lastCpuLimit,proto3" json:"last_cpu_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status_Usage) Reset()         { *m = Status_Usage{} }
func (m *Status_Usage) String() string { return proto.CompactTextString(m) }
func (*Status_Usage) ProtoMessage()    {}
func (*Status_Usage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{7, 0}
}
func (m *Status_Usage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Usage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Usage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Usage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Usage.Merge(m, src)
}
func (m *Status_Usage) XXX_Size() int {
	return m.Size()
}
func (m *Status_Usage) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Usage.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Usage proto.InternalMessageInfo

func (m *Status_Usage) GetDataVolumeInfo() *v11.DataVolumeInfo {
	if m != nil {
		return m.DataVolumeInfo
	}
	return nil
}

func (m *Status_Usage) GetLastMemoryUsage() int64 {
	if m != nil {
		return m.LastMemoryUsage
	}
	return 0
}

func (m *Status_Usage) GetLastCpuUsage() float32 {
	if m != nil {
		return m.LastCpuUsage
	}
	return 0
}

func (m *Status_Usage) GetLastMemoryLimit() int64 {
	if m != nil {
		return m.LastMemoryLimit
	}
	return 0
}

func (m *Status_Usage) GetLastCpuLimit() float32 {
	if m != nil {
		return m.LastCpuLimit
	}
	return 0
}

func init() {
	proto.RegisterType((*NotebookList)(nil), "arangodb.cloud.notebook.v1.NotebookList")
	proto.RegisterType((*ListNotebookRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebookRequest")
	proto.RegisterType((*Notebook)(nil), "arangodb.cloud.notebook.v1.Notebook")
	proto.RegisterType((*ModelSpec)(nil), "arangodb.cloud.notebook.v1.ModelSpec")
	proto.RegisterType((*NotebookModel)(nil), "arangodb.cloud.notebook.v1.NotebookModel")
	proto.RegisterType((*NotebookModelList)(nil), "arangodb.cloud.notebook.v1.NotebookModelList")
	proto.RegisterType((*ListNotebookModelRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebookModelRequest")
	proto.RegisterType((*Status)(nil), "arangodb.cloud.notebook.v1.Status")
	proto.RegisterType((*Status_Usage)(nil), "arangodb.cloud.notebook.v1.Status.Usage")
}

func init() { proto.RegisterFile("notebook.proto", fileDescriptor_e4288154b4c2ba34) }

var fileDescriptor_e4288154b4c2ba34 = []byte{
	// 1015 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdf, 0x6e, 0xdb, 0xb6,
	0x17, 0xfe, 0xc9, 0xae, 0x13, 0xfb, 0x24, 0x76, 0x53, 0xfe, 0x8a, 0x4e, 0xd3, 0x32, 0xc7, 0x55,
	0x92, 0xc2, 0x0d, 0x16, 0x19, 0xc9, 0xae, 0xd6, 0x02, 0x0d, 0x92, 0x66, 0x28, 0x32, 0xf4, 0x4f,
	0xa0, 0xb4, 0xbd, 0x18, 0x30, 0x08, 0xb4, 0xc9, 0xb8, 0x44, 0x25, 0x51, 0x33, 0x29, 0x03, 0x6e,
	0xb1, 0x61, 0xe8, 0x1b, 0x0c, 0xbb, 0xe9, 0xc3, 0xec, 0x01, 0x7a, 0x39, 0x60, 0xc0, 0xae, 0x87,
	0x6c, 0xaf, 0x31, 0x60, 0x20, 0x29, 0x39, 0xb6, 0x13, 0xd7, 0xce, 0xae, 0x4c, 0x1e, 0x7e, 0xe7,
	0x9c, 0x8f, 0xe7, 0xe3, 0x39, 0x32, 0xd4, 0x62, 0x2e, 0x69, 0x9b, 0xf3, 0xd7, 0x5e, 0xd2, 0xe3,
	0x92, 0x23, 0x07, 0xf7, 0x70, 0xdc, 0xe5, 0xa4, 0xed, 0x75, 0x42, 0x9e, 0x12, 0x6f, 0x78, 0xdc,
	0xdf, 0x71, 0x6e, 0x75, 0x78, 0x14, 0xf1, 0xb8, 0xd5, 0xdf, 0x69, 0x99, 0x95, 0xf1, 0x71, 0x10,
	0xc1, 0x12, 0x2b, 0xab, 0xfa, 0xcd, 0x6c, 0xf7, 0xbb, 0x4c, 0xbe, 0x4a, 0xdb, 0x5e, 0x87, 0x47,
	0xad, 0x2e, 0x0f, 0x71, 0xdc, 0x6d, 0xe9, 0x83, 0x76, 0x7a, 0xda, 0x4a, 0xe4, 0x20, 0xa1, 0xa2,
	0x25, 0x59, 0x44, 0x85, 0xc4, 0x51, 0x72, 0xbe, 0xca, 0x9c, 0x57, 0xbb, 0x9c, 0x77, 0x43, 0xda,
	0xc2, 0x09, 0x6b, 0xe1, 0x38, 0xe6, 0x12, 0x4b, 0xc6, 0x63, 0x61, 0x4e, 0xdd, 0x6f, 0x60, 0xf9,
	0x69, 0xc6, 0xea, 0x31, 0x13, 0x12, 0xdd, 0x83, 0x12, 0x93, 0x34, 0x12, 0xb6, 0xd5, 0x28, 0x36,
	0x97, 0x76, 0x37, 0xbc, 0xe9, 0x57, 0xf0, 0x72, 0x47, 0xdf, 0xb8, 0xb8, 0x6f, 0xe1, 0xff, 0x2a,
	0xc6, 0xd0, 0x4c, 0xbf, 0x4f, 0xa9, 0x90, 0x68, 0x1d, 0xaa, 0x84, 0x26, 0x21, 0x1f, 0x44, 0x34,
	0x96, 0x01, 0x23, 0xb6, 0xd5, 0xb0, 0x9a, 0x15, 0x7f, 0xf9, 0xdc, 0x78, 0x44, 0xd0, 0x1e, 0x2c,
	0xf2, 0x44, 0x13, 0xb3, 0xa1, 0x61, 0x35, 0x97, 0x76, 0x37, 0x27, 0x33, 0x67, 0x55, 0xea, 0xef,
	0x78, 0x2a, 0xc9, 0x33, 0x03, 0xf6, 0x73, 0x2f, 0xf7, 0x8f, 0x22, 0x94, 0xf3, 0xcc, 0xa8, 0x06,
	0x85, 0x61, 0x9e, 0x02, 0x23, 0x17, 0x29, 0x14, 0x2e, 0xa1, 0xb0, 0x02, 0xc5, 0xb4, 0x17, 0xda,
	0x45, 0x7d, 0xa4, 0x96, 0x08, 0xc1, 0xb5, 0x18, 0x47, 0xd4, 0xbe, 0xa6, 0x4d, 0x7a, 0x8d, 0x1a,
	0xb0, 0x44, 0xa8, 0xe8, 0xf4, 0x98, 0xce, 0x6b, 0x97, 0xf4, 0xd1, 0xa8, 0x09, 0x7d, 0x06, 0x15,
	0x26, 0x82, 0x04, 0xa7, 0x82, 0x12, 0x7b, 0xa1, 0x61, 0x35, 0xcb, 0x7e, 0x99, 0x89, 0x63, 0xbd,
	0x47, 0x2e, 0x54, 0x3b, 0x3d, 0x8a, 0x25, 0x25, 0x41, 0x7b, 0xa0, 0x98, 0x2c, 0x9a, 0x00, 0x99,
	0xf1, 0x60, 0x70, 0x44, 0xd0, 0x57, 0x00, 0x39, 0x06, 0x4b, 0xbb, 0xac, 0xcb, 0xe1, 0x78, 0x46,
	0x46, 0x2f, 0x17, 0xde, 0x7b, 0x9e, 0xeb, 0xec, 0x57, 0x32, 0xf4, 0xbe, 0x44, 0xf7, 0xa1, 0x14,
	0x71, 0x42, 0x43, 0xbb, 0x72, 0x79, 0x11, 0x47, 0xe5, 0x7b, 0xa2, 0x80, 0x27, 0x09, 0xed, 0xf8,
	0xc6, 0x07, 0x7d, 0x0e, 0xc0, 0x44, 0x40, 0x68, 0x48, 0x25, 0x25, 0x5a, 0x86, 0xb2, 0x5f, 0x61,
	0xe2, 0xd0, 0x18, 0x14, 0xad, 0xec, 0x4c, 0xd1, 0x5a, 0x9a, 0x4d, 0x2b, 0x43, 0xef, 0xab, 0x57,
	0xb5, 0x20, 0x24, 0x96, 0xa9, 0xb0, 0x89, 0x76, 0x73, 0x3f, 0xc6, 0xeb, 0x44, 0x23, 0xfd, 0xcc,
	0xc3, 0x7d, 0x06, 0x95, 0x21, 0x53, 0xb4, 0x79, 0xde, 0x63, 0x81, 0xb9, 0xa8, 0x11, 0xb9, 0x9a,
	0x5b, 0x35, 0x54, 0x49, 0x40, 0x98, 0x78, 0x1d, 0x08, 0xf6, 0x86, 0x66, 0x5a, 0x97, 0x95, 0xe1,
	0x84, 0xbd, 0xa1, 0xee, 0x77, 0x50, 0x7d, 0x3a, 0x86, 0x9e, 0x7c, 0x2d, 0xb9, 0xec, 0x85, 0x11,
	0xd9, 0x57, 0xa0, 0xd8, 0x49, 0x52, 0xfd, 0x38, 0x4a, 0xbe, 0x5a, 0xa2, 0x5b, 0xb0, 0x10, 0xd1,
	0x88, 0xf7, 0x06, 0xfa, 0x79, 0x94, 0xfc, 0x6c, 0xe7, 0x3e, 0x87, 0x1b, 0x63, 0xe1, 0x75, 0x5b,
	0xed, 0x8d, 0xb7, 0xd5, 0xdd, 0x79, 0xda, 0x4a, 0x7b, 0xe7, 0xbd, 0xb5, 0x07, 0xf6, 0x68, 0x6f,
	0x99, 0xb3, 0x2b, 0x34, 0x98, 0xfb, 0x6b, 0x11, 0x16, 0x4c, 0x65, 0xd1, 0x4d, 0x28, 0x25, 0xaf,
	0xb0, 0xa0, 0x19, 0xce, 0x6c, 0x90, 0x0d, 0x8b, 0x11, 0x15, 0x02, 0x77, 0xf3, 0x8b, 0xe7, 0x5b,
	0x74, 0x00, 0xd7, 0x43, 0x2c, 0x64, 0x90, 0x26, 0x24, 0x7f, 0x94, 0xc5, 0x99, 0xea, 0x57, 0x95,
	0xcb, 0x0b, 0xe3, 0xb1, 0x2f, 0xd1, 0x03, 0x28, 0xa5, 0x3a, 0xb6, 0xe9, 0xee, 0xe6, 0xec, 0x07,
	0xe0, 0xbd, 0x50, 0x78, 0xdf, 0xb8, 0x39, 0xff, 0x58, 0x50, 0xd2, 0x06, 0x74, 0x0c, 0x2b, 0x6a,
	0x34, 0x06, 0x7d, 0x1e, 0xa6, 0x11, 0x0d, 0x58, 0x7c, 0xca, 0xed, 0x9b, 0x3a, 0xe8, 0x9d, 0xc9,
	0xa0, 0x7a, 0x84, 0xf6, 0x77, 0xbc, 0x43, 0x2c, 0xf1, 0x4b, 0x0d, 0x3f, 0x8a, 0x4f, 0xb9, 0x5f,
	0x23, 0x63, 0x7b, 0xb4, 0x05, 0x37, 0xf4, 0xfd, 0x8c, 0x80, 0x81, 0xe1, 0xb9, 0xd6, 0xb0, 0x9a,
	0x45, 0x5f, 0x5f, 0xfc, 0x89, 0xb6, 0x9b, 0xec, 0x1b, 0x50, 0xd3, 0xd8, 0x4e, 0x92, 0x66, 0xc0,
	0x46, 0xc3, 0x6a, 0x16, 0xfc, 0x65, 0x65, 0x7d, 0x98, 0xa4, 0x06, 0x35, 0x11, 0x31, 0x64, 0x11,
	0x93, 0xf6, 0xed, 0xc9, 0x88, 0x8f, 0x95, 0x79, 0x2c, 0xa2, 0x01, 0xba, 0x63, 0x11, 0x35, 0x6a,
	0xf7, 0xc3, 0x22, 0x5c, 0xcf, 0xc5, 0x3f, 0xa1, 0xbd, 0x3e, 0xeb, 0x50, 0x34, 0x80, 0xea, 0x23,
	0x2a, 0xf7, 0x8f, 0x8f, 0x5e, 0xd2, 0x9e, 0x50, 0x93, 0x67, 0x6d, 0xfa, 0xcc, 0xfc, 0x3a, 0x4a,
	0xe4, 0xc0, 0xb9, 0x3d, 0x1d, 0x90, 0xc5, 0x70, 0x37, 0xde, 0xfd, 0xfe, 0xf7, 0x2f, 0x85, 0x3a,
	0x5a, 0xd5, 0x1f, 0x8c, 0x5c, 0x16, 0xf5, 0x41, 0xc2, 0x09, 0xdb, 0xee, 0x67, 0x99, 0x7e, 0xb2,
	0x60, 0xe9, 0x11, 0x1d, 0x3e, 0x47, 0xb4, 0x3e, 0x3d, 0xf0, 0xd1, 0x61, 0x36, 0xab, 0x9d, 0xb9,
	0x3e, 0x26, 0xee, 0x1d, 0x4d, 0xa0, 0x81, 0xea, 0x17, 0x08, 0x0c, 0xd7, 0x6f, 0x19, 0xf9, 0x01,
	0xbd, 0xb3, 0xa0, 0xf6, 0x50, 0x0f, 0xbe, 0x21, 0x8b, 0xb9, 0x12, 0xcc, 0x49, 0x23, 0xab, 0x83,
	0xf3, 0xe9, 0x54, 0x1a, 0xf7, 0xac, 0x2d, 0xf4, 0x23, 0xd4, 0xcc, 0x78, 0xbc, 0x5a, 0x25, 0x66,
	0x09, 0x95, 0x17, 0x61, 0x6b, 0x9e, 0x22, 0x98, 0x26, 0xbb, 0x62, 0x11, 0x66, 0x32, 0xb8, 0xab,
	0x19, 0xac, 0xbb, 0x33, 0x18, 0xa8, 0x22, 0xfc, 0x6c, 0x41, 0x75, 0x74, 0x38, 0x09, 0xd4, 0xfa,
	0x18, 0x87, 0x4b, 0xfe, 0x23, 0x38, 0xcd, 0x79, 0x48, 0x2b, 0x47, 0x77, 0x53, 0xf3, 0x5a, 0x73,
	0x9d, 0xa9, 0xbc, 0x84, 0xe2, 0xf4, 0xde, 0x02, 0x74, 0x61, 0x60, 0xfe, 0x07, 0x62, 0xdb, 0x73,
	0x4f, 0x6a, 0xcd, 0xce, 0xd5, 0xec, 0x56, 0xdd, 0x4f, 0x2e, 0xb0, 0xd3, 0x5f, 0x2b, 0x45, 0xed,
	0xe0, 0xc1, 0x87, 0xb3, 0xba, 0xf5, 0xdb, 0x59, 0xdd, 0xfa, 0xf3, 0xac, 0x6e, 0xbd, 0xff, 0xab,
	0xfe, 0xbf, 0x6f, 0xbf, 0x18, 0xf9, 0x7f, 0x97, 0xa7, 0xdb, 0x8e, 0x70, 0x8c, 0xbb, 0x94, 0xa8,
	0x40, 0x62, 0x34, 0x52, 0x7b, 0x41, 0x4f, 0xdb, 0x2f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x33,
	0x5c, 0x77, 0x31, 0x6e, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NotebookServiceClient is the client API for NotebookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotebookServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*Notebook, error)
	// Delete an existing notebook using its ID.
	// This initially marks the notebook for deletion. It is deleted from CP once all its child resources are deleted.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Update an existing notebook. Returns updated Notebook.
	// Required permissions:
	// - notebook.notebook.update
	UpdateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*v1.Empty, error)
	// List all notebooks for deployment.
	// Note: This lists only those notebooks created by the caller.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error)
	// List all notebook models available to a deployment.
	// Required permissions:
	// - notebook.model.list
	ListNotebookModels(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookModelList, error)
}

type notebookServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotebookServiceClient(cc *grpc.ClientConn) NotebookServiceClient {
	return &notebookServiceClient{cc}
}

func (c *notebookServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) CreateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) UpdateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/UpdateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error) {
	out := new(NotebookList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebookModels(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookModelList, error) {
	out := new(NotebookModelList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebookModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotebookServiceServer is the server API for NotebookService service.
type NotebookServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(context.Context, *v1.IDOptions) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(context.Context, *Notebook) (*Notebook, error)
	// Delete an existing notebook using its ID.
	// This initially marks the notebook for deletion. It is deleted from CP once all its child resources are deleted.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Update an existing notebook. Returns updated Notebook.
	// Required permissions:
	// - notebook.notebook.update
	UpdateNotebook(context.Context, *Notebook) (*v1.Empty, error)
	// List all notebooks for deployment.
	// Note: This lists only those notebooks created by the caller.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(context.Context, *ListNotebookRequest) (*NotebookList, error)
	// List all notebook models available to a deployment.
	// Required permissions:
	// - notebook.model.list
	ListNotebookModels(context.Context, *ListNotebookRequest) (*NotebookModelList, error)
}

// UnimplementedNotebookServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNotebookServiceServer struct {
}

func (*UnimplementedNotebookServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedNotebookServiceServer) GetNotebook(ctx context.Context, req *v1.IDOptions) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) CreateNotebook(ctx context.Context, req *Notebook) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) DeleteNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) UpdateNotebook(ctx context.Context, req *Notebook) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebooks(ctx context.Context, req *ListNotebookRequest) (*NotebookList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebooks not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebookModels(ctx context.Context, req *ListNotebookRequest) (*NotebookModelList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebookModels not implemented")
}

func RegisterNotebookServiceServer(s *grpc.Server, srv NotebookServiceServer) {
	s.RegisterService(&_NotebookService_serviceDesc, srv)
}

func _NotebookService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_GetNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_CreateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notebook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, req.(*Notebook))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_DeleteNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_UpdateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notebook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).UpdateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/UpdateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).UpdateNotebook(ctx, req.(*Notebook))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, req.(*ListNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebookModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebookModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebookModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebookModels(ctx, req.(*ListNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotebookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.notebook.v1.NotebookService",
	HandlerType: (*NotebookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _NotebookService_GetAPIVersion_Handler,
		},
		{
			MethodName: "GetNotebook",
			Handler:    _NotebookService_GetNotebook_Handler,
		},
		{
			MethodName: "CreateNotebook",
			Handler:    _NotebookService_CreateNotebook_Handler,
		},
		{
			MethodName: "DeleteNotebook",
			Handler:    _NotebookService_DeleteNotebook_Handler,
		},
		{
			MethodName: "UpdateNotebook",
			Handler:    _NotebookService_UpdateNotebook_Handler,
		},
		{
			MethodName: "ListNotebooks",
			Handler:    _NotebookService_ListNotebooks_Handler,
		},
		{
			MethodName: "ListNotebookModels",
			Handler:    _NotebookService_ListNotebookModels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notebook.proto",
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreatedById) > 0 {
		i -= len(m.CreatedById)
		copy(dAtA[i:], m.CreatedById)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.CreatedById)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsPaused {
		i--
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DiskSize) > 0 {
		i -= len(m.DiskSize)
		copy(dAtA[i:], m.DiskSize)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DiskSize)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NotebookModel) > 0 {
		i -= len(m.NotebookModel)
		copy(dAtA[i:], m.NotebookModel)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.NotebookModel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memory != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x20
	}
	if m.Cpu != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookModelList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookModelList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebookModelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebookModelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebookModelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Usage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Usage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Usage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastCpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuLimit))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x95
	}
	if m.LastMemoryLimit != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.LastMemoryLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.LastCpuUsage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuUsage))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.LastMemoryUsage != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.LastMemoryUsage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.DataVolumeInfo != nil {
		{
			size, err := m.DataVolumeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotebook(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotebook(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.IsPaused {
		n += 2
	}
	l = len(m.CreatedById)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NotebookModel)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotebookModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Cpu != 0 {
		n += 1 + sovNotebook(uint64(m.Cpu))
	}
	if m.Memory != 0 {
		n += 1 + sovNotebook(uint64(m.Memory))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotebookModelList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebookModelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status_Usage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataVolumeInfo != nil {
		l = m.DataVolumeInfo.Size()
		n += 2 + l + sovNotebook(uint64(l))
	}
	if m.LastMemoryUsage != 0 {
		n += 2 + sovNotebook(uint64(m.LastMemoryUsage))
	}
	if m.LastCpuUsage != 0 {
		n += 6
	}
	if m.LastMemoryLimit != 0 {
		n += 2 + sovNotebook(uint64(m.LastMemoryLimit))
	}
	if m.LastCpuLimit != 0 {
		n += 6
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotebook(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotebook(x uint64) (n int) {
	return sovNotebook(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &ModelSpec{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotebookModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NotebookModel{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebookModelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebookModelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebookModelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &Status_Usage{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Usage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Usage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Usage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataVolumeInfo == nil {
				m.DataVolumeInfo = &v11.DataVolumeInfo{}
			}
			if err := m.DataVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryUsage", wireType)
			}
			m.LastMemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuUsage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuUsage = float32(math.Float32frombits(v))
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryLimit", wireType)
			}
			m.LastMemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuLimit = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotebook(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotebook
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotebook
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotebook
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotebook        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotebook          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotebook = fmt.Errorf("proto: unexpected end of group")
)
