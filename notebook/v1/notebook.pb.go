// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: notebook.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// List of Notebooks.
type NotebookList struct {
	Items                []*Notebook `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NotebookList) Reset()         { *m = NotebookList{} }
func (m *NotebookList) String() string { return proto.CompactTextString(m) }
func (*NotebookList) ProtoMessage()    {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{0}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookList) GetItems() []*Notebook {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request for listing notebooks.
type ListNotebookRequest struct {
	// List notebooks for this deployment ID.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Optional common list options, the context_id is ignored
	Options              *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListNotebookRequest) Reset()         { *m = ListNotebookRequest{} }
func (m *ListNotebookRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebookRequest) ProtoMessage()    {}
func (*ListNotebookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{1}
}
func (m *ListNotebookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebookRequest.Merge(m, src)
}
func (m *ListNotebookRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebookRequest proto.InternalMessageInfo

func (m *ListNotebookRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *ListNotebookRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Request for creating a notebook.
type CreateNotebookRequest struct {
	// ID of the Deployment this notebook belongs to.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Configuration of the notebook instance.
	Spec                 *Spec    `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateNotebookRequest) Reset()         { *m = CreateNotebookRequest{} }
func (m *CreateNotebookRequest) String() string { return proto.CompactTextString(m) }
func (*CreateNotebookRequest) ProtoMessage()    {}
func (*CreateNotebookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{2}
}
func (m *CreateNotebookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateNotebookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateNotebookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateNotebookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateNotebookRequest.Merge(m, src)
}
func (m *CreateNotebookRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateNotebookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateNotebookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateNotebookRequest proto.InternalMessageInfo

func (m *CreateNotebookRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *CreateNotebookRequest) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Contains the specification and status of a given notebook instance.
type Notebook struct {
	// ID of the Notebook.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the Deployment this notebook belongs to.
	DeploymentId string `protobuf:"bytes,2,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Set if the notebook should be shutdown.
	Shutdown bool `protobuf:"varint,3,opt,name=shutdown,proto3" json:"shutdown,omitempty"`
	// Identifier of the entity responsible for shutting down the notebook.
	ShutdownBy string `protobuf:"bytes,4,opt,name=shutdown_by,json=shutdownBy,proto3" json:"shutdown_by,omitempty"`
	// Set if the notebook should be paused.
	Paused bool `protobuf:"varint,5,opt,name=paused,proto3" json:"paused,omitempty"`
	// Identifier of the entity responsible for pausing the notebook.
	PausedBy string `protobuf:"bytes,6,opt,name=paused_by,json=pausedBy,proto3" json:"paused_by,omitempty"`
	// Configuration of the notebook instance.
	Spec *Spec `protobuf:"bytes,7,opt,name=spec,proto3" json:"spec,omitempty"`
	// Status of the notebook. Represents the state of the notebook as observed by the controller.
	// Note: all fields in this block are read-only.
	Status               *Status  `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notebook) Reset()         { *m = Notebook{} }
func (m *Notebook) String() string { return proto.CompactTextString(m) }
func (*Notebook) ProtoMessage()    {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{3}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notebook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *Notebook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notebook) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Notebook) GetShutdown() bool {
	if m != nil {
		return m.Shutdown
	}
	return false
}

func (m *Notebook) GetShutdownBy() string {
	if m != nil {
		return m.ShutdownBy
	}
	return ""
}

func (m *Notebook) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *Notebook) GetPausedBy() string {
	if m != nil {
		return m.PausedBy
	}
	return ""
}

func (m *Notebook) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Notebook) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Specification options for a notebook.
type Spec struct {
	// Number of CPU units required by the notebook instance.
	CPU int32 `protobuf:"varint,1,opt,name=CPU,proto3" json:"CPU,omitempty"`
	// Memory required by the notebook instance.
	// Should be expressed as memibyte (Mi).
	Memory int32 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// Disk space required by the notebook instance.
	// Should be expressed as power-of-two: Mi, Gi, Ti, Pi, etc.
	Disk                 string   `protobuf:"bytes,3,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spec) Reset()         { *m = Spec{} }
func (m *Spec) String() string { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()    {}
func (*Spec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{4}
}
func (m *Spec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spec.Merge(m, src)
}
func (m *Spec) XXX_Size() int {
	return m.Size()
}
func (m *Spec) XXX_DiscardUnknown() {
	xxx_messageInfo_Spec.DiscardUnknown(m)
}

var xxx_messageInfo_Spec proto.InternalMessageInfo

func (m *Spec) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *Spec) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Spec) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

// Contains details for the current state of the notebook.
type Condition struct {
	// Type of condition being reported.
	// Should be one of the following:
	// - Paused
	// - Stopped
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Status of the condition, one of true or false.
	Status bool `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// Identifier of the entity responsible for the conditions's last transition.
	TriggeredBy string `protobuf:"bytes,3,opt,name=triggered_by,json=triggeredBy,proto3" json:"triggered_by,omitempty"`
	// Reason for the condition's last transition.
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// The last time the condition transitioned from one status to another.
	LastTransitionTime   *types.Timestamp `protobuf:"bytes,5,opt,name=last_transition_time,json=lastTransitionTime,proto3" json:"last_transition_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{5}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Condition) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *Condition) GetTriggeredBy() string {
	if m != nil {
		return m.TriggeredBy
	}
	return ""
}

func (m *Condition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Condition) GetLastTransitionTime() *types.Timestamp {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

// Status of the notebook. Represents the state of the notebook as observed by the controller.
// Note: all fields in this block are read-only.
type Status struct {
	// Where the notebook is in its lifecycle at any given time.
	// Should only contain only one of the following values:
	// "Initialising"   - Notebook is initialising.
	// "Running"        - Notebook is running.
	// "Error"          - Notebook is in an errored state. Additional information can be obtained from `message` field.
	Phase string `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	// Supporting information about the notebook phase - such as error messages in case of failures.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// The last time the notebook was updated.
	LastUpdatedAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Contains details for the current state of the notebook.
	Conditions           []*Condition `protobuf:"bytes,4,rep,name=conditions,proto3" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{6}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

func (m *Status) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func init() {
	proto.RegisterType((*NotebookList)(nil), "arangodb.cloud.notebook.v1.NotebookList")
	proto.RegisterType((*ListNotebookRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebookRequest")
	proto.RegisterType((*CreateNotebookRequest)(nil), "arangodb.cloud.notebook.v1.CreateNotebookRequest")
	proto.RegisterType((*Notebook)(nil), "arangodb.cloud.notebook.v1.Notebook")
	proto.RegisterType((*Spec)(nil), "arangodb.cloud.notebook.v1.Spec")
	proto.RegisterType((*Condition)(nil), "arangodb.cloud.notebook.v1.Condition")
	proto.RegisterType((*Status)(nil), "arangodb.cloud.notebook.v1.Status")
}

func init() { proto.RegisterFile("notebook.proto", fileDescriptor_e4288154b4c2ba34) }

var fileDescriptor_e4288154b4c2ba34 = []byte{
	// 888 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x67, 0x1c, 0xdb, 0x71, 0x9e, 0x63, 0xb7, 0x1a, 0x4a, 0xb5, 0x2c, 0x95, 0xe3, 0x6e, 0x93,
	0xd6, 0x44, 0xcd, 0xae, 0x12, 0x38, 0x05, 0x09, 0x54, 0x27, 0x55, 0x15, 0x54, 0x41, 0xb4, 0x69,
	0x39, 0x70, 0xb1, 0xc6, 0xde, 0x61, 0xb3, 0xaa, 0x77, 0x67, 0xd9, 0x99, 0x35, 0xb2, 0x2a, 0x10,
	0x02, 0x71, 0x80, 0x1b, 0xe2, 0xc2, 0x9d, 0x2f, 0x82, 0xc4, 0x05, 0x71, 0x42, 0xe2, 0x0b, 0xa0,
	0xc0, 0x07, 0x41, 0xf3, 0x67, 0xb7, 0x86, 0xc4, 0x76, 0xa8, 0x72, 0x7b, 0x6f, 0x66, 0x7e, 0xef,
	0xfd, 0xde, 0x6f, 0xe6, 0xbd, 0x5d, 0x68, 0x27, 0x4c, 0xd0, 0x21, 0x63, 0xcf, 0xdc, 0x34, 0x63,
	0x82, 0x61, 0x9b, 0x64, 0x24, 0x09, 0x59, 0x30, 0x74, 0x47, 0x63, 0x96, 0x07, 0x6e, 0xb9, 0x3d,
	0xd9, 0xb5, 0x6f, 0x8e, 0x58, 0x1c, 0xb3, 0xc4, 0x9b, 0xec, 0x7a, 0xda, 0xd2, 0x18, 0xfb, 0x9d,
	0x30, 0x12, 0xa7, 0xf9, 0xd0, 0x1d, 0xb1, 0xd8, 0x0b, 0xd9, 0x98, 0x24, 0xa1, 0xa7, 0x36, 0x86,
	0xf9, 0x27, 0x5e, 0x2a, 0xa6, 0x29, 0xe5, 0x9e, 0x88, 0x62, 0xca, 0x05, 0x89, 0xd3, 0x17, 0x96,
	0x01, 0xdf, 0x0a, 0x19, 0x0b, 0xc7, 0xd4, 0x23, 0x69, 0xe4, 0x91, 0x24, 0x61, 0x82, 0x88, 0x88,
	0x25, 0x5c, 0xef, 0x3a, 0xef, 0xc3, 0xfa, 0x07, 0x86, 0xc1, 0xe3, 0x88, 0x0b, 0xbc, 0x0f, 0xb5,
	0x48, 0xd0, 0x98, 0x5b, 0xa8, 0xbb, 0xd2, 0x6b, 0xee, 0x6d, 0xba, 0xf3, 0xe9, 0xba, 0x05, 0xd0,
	0xd7, 0x10, 0xe7, 0x39, 0xbc, 0x2a, 0x63, 0x94, 0xcb, 0xf4, 0xd3, 0x9c, 0x72, 0x81, 0xef, 0x40,
	0x2b, 0xa0, 0xe9, 0x98, 0x4d, 0x63, 0x9a, 0x88, 0x41, 0x14, 0x58, 0xa8, 0x8b, 0x7a, 0x6b, 0xfe,
	0xfa, 0x8b, 0xc5, 0xa3, 0x00, 0xbf, 0x07, 0xab, 0x2c, 0x55, 0xc4, 0x2c, 0xe8, 0xa2, 0x5e, 0x73,
	0x6f, 0xeb, 0xbf, 0x99, 0x8d, 0x22, 0x93, 0x5d, 0x57, 0x26, 0xf9, 0x50, 0x1f, 0xf6, 0x0b, 0x94,
	0x93, 0xc1, 0x6b, 0x07, 0x19, 0x25, 0x82, 0xbe, 0x54, 0xfa, 0xb7, 0xa1, 0xca, 0x53, 0x3a, 0xb2,
	0x2a, 0x2a, 0x77, 0x77, 0x51, 0xd5, 0x27, 0x29, 0x1d, 0xf9, 0xea, 0xb4, 0xf3, 0x53, 0x05, 0x1a,
	0x45, 0x3a, 0xdc, 0x86, 0x4a, 0x19, 0xbc, 0x12, 0x05, 0xe7, 0xf3, 0x56, 0x2e, 0xc8, 0x6b, 0x43,
	0x83, 0x9f, 0xe6, 0x22, 0x60, 0x9f, 0x25, 0xd6, 0x4a, 0x17, 0xf5, 0x1a, 0x7e, 0xe9, 0xe3, 0x0d,
	0x68, 0x16, 0xf6, 0x60, 0x38, 0xb5, 0xaa, 0x0a, 0x0e, 0xc5, 0x52, 0x7f, 0x8a, 0x6f, 0x42, 0x3d,
	0x25, 0x39, 0xa7, 0x81, 0x55, 0x53, 0x50, 0xe3, 0xe1, 0x37, 0x60, 0x4d, 0x5b, 0x12, 0x56, 0x57,
	0xb0, 0x86, 0x5e, 0xe8, 0x4f, 0xcb, 0x4a, 0x57, 0xff, 0x4f, 0xa5, 0x78, 0x1f, 0xea, 0x5c, 0x10,
	0x91, 0x17, 0xb7, 0xe3, 0x2c, 0xc4, 0xa9, 0x93, 0xbe, 0x41, 0x38, 0x87, 0x50, 0x95, 0x91, 0xf0,
	0x75, 0x58, 0x39, 0x38, 0x7e, 0xaa, 0x14, 0xaa, 0xf9, 0xd2, 0x94, 0x05, 0xc4, 0x34, 0x66, 0xd9,
	0x54, 0x69, 0x53, 0xf3, 0x8d, 0x87, 0x31, 0x54, 0x83, 0x88, 0x3f, 0x53, 0x8a, 0xac, 0xf9, 0xca,
	0x76, 0x7e, 0x46, 0xb0, 0x76, 0xc0, 0x92, 0x20, 0x92, 0xd7, 0x2d, 0x4f, 0xc8, 0x77, 0x6f, 0xe4,
	0x56, 0xb6, 0x8c, 0x66, 0x38, 0x56, 0xb4, 0x1c, 0xda, 0xc3, 0xb7, 0x61, 0x5d, 0x64, 0x51, 0x18,
	0xd2, 0x4c, 0x2b, 0xa2, 0xa3, 0x36, 0xcb, 0x35, 0xad, 0x64, 0x46, 0x09, 0x67, 0x89, 0x51, 0xd9,
	0x78, 0xf8, 0x31, 0xdc, 0x18, 0x13, 0x2e, 0x06, 0x22, 0x23, 0x09, 0x57, 0x99, 0x07, 0xb2, 0xbd,
	0x94, 0xde, 0xcd, 0x3d, 0xdb, 0xd5, 0xad, 0xe5, 0x16, 0xcd, 0xe8, 0x3e, 0x29, 0x7a, 0xcf, 0xc7,
	0x12, 0xf7, 0xa4, 0x84, 0xc9, 0x0d, 0xe7, 0x17, 0x04, 0x75, 0xad, 0x0d, 0xbe, 0x01, 0xb5, 0xf4,
	0x94, 0xf0, 0xa2, 0x00, 0xed, 0x60, 0x0b, 0x56, 0x63, 0xca, 0x39, 0x09, 0xa9, 0x79, 0x2c, 0x85,
	0x8b, 0xfb, 0x70, 0x4d, 0x11, 0xc9, 0xd3, 0x80, 0x08, 0x1a, 0x0c, 0x88, 0x50, 0x65, 0x2c, 0xe6,
	0xd0, 0x92, 0x90, 0xa7, 0x1a, 0xf1, 0x40, 0xe0, 0x87, 0x00, 0xa3, 0x42, 0x40, 0x6e, 0x55, 0x55,
	0x7f, 0x6f, 0x2d, 0xba, 0xc7, 0x52, 0x6e, 0x7f, 0x06, 0xb8, 0xf7, 0x5b, 0x03, 0xae, 0x15, 0x8f,
	0xfe, 0x84, 0x66, 0x93, 0x68, 0x44, 0xf1, 0x14, 0x5a, 0x8f, 0xa8, 0x78, 0x70, 0x7c, 0xf4, 0x11,
	0xcd, 0xb8, 0xbc, 0x9f, 0x8d, 0xf9, 0xdd, 0xfb, 0x30, 0x4e, 0xc5, 0xd4, 0xbe, 0x3d, 0xff, 0x80,
	0x89, 0xe1, 0x6c, 0x7e, 0xf5, 0xc7, 0xdf, 0x3f, 0x54, 0x3a, 0xf8, 0x96, 0x1a, 0x5d, 0x05, 0x31,
	0x39, 0x1c, 0x49, 0x1a, 0xed, 0x4c, 0x4c, 0xa6, 0x2f, 0x11, 0x34, 0x1f, 0xd1, 0x72, 0xe8, 0xe0,
	0x3b, 0xf3, 0x03, 0x1f, 0x1d, 0x9a, 0xa9, 0x61, 0x5f, 0x6a, 0xac, 0x39, 0x77, 0x15, 0x81, 0x2e,
	0xee, 0x9c, 0x23, 0x50, 0xda, 0xcf, 0xa3, 0xe0, 0x73, 0xfc, 0x1d, 0x82, 0xf6, 0xbf, 0x67, 0x0f,
	0xde, 0x5d, 0xa8, 0xeb, 0x45, 0x73, 0xca, 0x5e, 0x26, 0x59, 0xa1, 0x87, 0xfd, 0xfa, 0x5c, 0x3a,
	0xfb, 0x68, 0x1b, 0x7f, 0x01, 0xed, 0x43, 0x3a, 0xa6, 0x33, 0x5c, 0x2e, 0xa5, 0xc8, 0xd2, 0xec,
	0x46, 0x8c, 0xed, 0x65, 0x62, 0x7c, 0x8b, 0xe0, 0xfa, 0x89, 0x99, 0x51, 0x57, 0x4c, 0xc1, 0x53,
	0x14, 0xde, 0x74, 0xee, 0x2d, 0xa6, 0xe0, 0x95, 0x13, 0xf4, 0x6b, 0x04, 0xad, 0x63, 0x39, 0xf8,
	0xae, 0x98, 0xc8, 0x7d, 0x45, 0xe4, 0xae, 0xb3, 0xb9, 0x84, 0x88, 0x1a, 0xba, 0xf8, 0x1b, 0x04,
	0x6d, 0x9f, 0xf2, 0x3c, 0xbe, 0x6a, 0x1a, 0x3b, 0x8a, 0xc6, 0x3d, 0x67, 0x6b, 0x09, 0x8d, 0x4c,
	0x25, 0xc7, 0xdf, 0x23, 0x68, 0xcd, 0x7e, 0x9f, 0x39, 0xf6, 0x16, 0xbd, 0xd2, 0x0b, 0x3e, 0xe5,
	0x76, 0xef, 0x32, 0x7d, 0x23, 0x81, 0xce, 0x96, 0xe2, 0xb6, 0xe1, 0xd8, 0x73, 0xb9, 0xf1, 0x7d,
	0xb4, 0xdd, 0x7f, 0xf7, 0xd7, 0xb3, 0x0e, 0xfa, 0xfd, 0xac, 0x83, 0xfe, 0x3c, 0xeb, 0xa0, 0x1f,
	0xff, 0xea, 0xbc, 0xf2, 0xf1, 0xfd, 0x99, 0x7f, 0x9d, 0x22, 0xd9, 0x4e, 0x4c, 0x12, 0x12, 0xd2,
	0x40, 0xc6, 0xe2, 0xb3, 0xc1, 0x86, 0x75, 0x35, 0xf6, 0xde, 0xfa, 0x27, 0x00, 0x00, 0xff, 0xff,
	0xf1, 0x90, 0xa4, 0xf4, 0x66, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NotebookServiceClient is the client API for NotebookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotebookServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(ctx context.Context, in *CreateNotebookRequest, opts ...grpc.CallOption) (*v1.Empty, error)
	// Delete an existing notebook using its ID.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Shutdown a running notebook.
	// Required permissions:
	// - notebook.notebook.shutdown
	ShutdownNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Pause a running notebook. This will move the notebook to a hibernating state.
	// Required permissions:
	// - notebook.notebook.pause
	PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Resume a paused notebook. This will remove the notebook from a hibernating state.
	// Required permissions:
	// - notebook.notebook.resume
	ResumeNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// List all notebooks for a deployment.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error)
}

type notebookServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotebookServiceClient(cc *grpc.ClientConn) NotebookServiceClient {
	return &notebookServiceClient{cc}
}

func (c *notebookServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) CreateNotebook(ctx context.Context, in *CreateNotebookRequest, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ShutdownNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ShutdownNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ResumeNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ResumeNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebooks(ctx context.Context, in *ListNotebookRequest, opts ...grpc.CallOption) (*NotebookList, error) {
	out := new(NotebookList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotebookServiceServer is the server API for NotebookService service.
type NotebookServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get
	GetNotebook(context.Context, *v1.IDOptions) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create
	CreateNotebook(context.Context, *CreateNotebookRequest) (*v1.Empty, error)
	// Delete an existing notebook using its ID.
	// Required permissions:
	// - notebook.notebook.delete
	DeleteNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Shutdown a running notebook.
	// Required permissions:
	// - notebook.notebook.shutdown
	ShutdownNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Pause a running notebook. This will move the notebook to a hibernating state.
	// Required permissions:
	// - notebook.notebook.pause
	PauseNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Resume a paused notebook. This will remove the notebook from a hibernating state.
	// Required permissions:
	// - notebook.notebook.resume
	ResumeNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// List all notebooks for a deployment.
	// Required permissions:
	// - notebook.notebook.list
	ListNotebooks(context.Context, *ListNotebookRequest) (*NotebookList, error)
}

// UnimplementedNotebookServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNotebookServiceServer struct {
}

func (*UnimplementedNotebookServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedNotebookServiceServer) GetNotebook(ctx context.Context, req *v1.IDOptions) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) CreateNotebook(ctx context.Context, req *CreateNotebookRequest) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) DeleteNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ShutdownNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) PauseNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ResumeNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebooks(ctx context.Context, req *ListNotebookRequest) (*NotebookList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebooks not implemented")
}

func RegisterNotebookServiceServer(s *grpc.Server, srv NotebookServiceServer) {
	s.RegisterService(&_NotebookService_serviceDesc, srv)
}

func _NotebookService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_GetNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_CreateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, req.(*CreateNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_DeleteNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ShutdownNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ShutdownNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ShutdownNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ShutdownNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_PauseNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ResumeNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ResumeNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ResumeNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ResumeNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, req.(*ListNotebookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotebookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.notebook.v1.NotebookService",
	HandlerType: (*NotebookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _NotebookService_GetAPIVersion_Handler,
		},
		{
			MethodName: "GetNotebook",
			Handler:    _NotebookService_GetNotebook_Handler,
		},
		{
			MethodName: "CreateNotebook",
			Handler:    _NotebookService_CreateNotebook_Handler,
		},
		{
			MethodName: "DeleteNotebook",
			Handler:    _NotebookService_DeleteNotebook_Handler,
		},
		{
			MethodName: "ShutdownNotebook",
			Handler:    _NotebookService_ShutdownNotebook_Handler,
		},
		{
			MethodName: "PauseNotebook",
			Handler:    _NotebookService_PauseNotebook_Handler,
		},
		{
			MethodName: "ResumeNotebook",
			Handler:    _NotebookService_ResumeNotebook_Handler,
		},
		{
			MethodName: "ListNotebooks",
			Handler:    _NotebookService_ListNotebooks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notebook.proto",
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateNotebookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNotebookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateNotebookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PausedBy) > 0 {
		i -= len(m.PausedBy)
		copy(dAtA[i:], m.PausedBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.PausedBy)))
		i--
		dAtA[i] = 0x32
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ShutdownBy) > 0 {
		i -= len(m.ShutdownBy)
		copy(dAtA[i:], m.ShutdownBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.ShutdownBy)))
		i--
		dAtA[i] = 0x22
	}
	if m.Shutdown {
		i--
		if m.Shutdown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Spec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Disk) > 0 {
		i -= len(m.Disk)
		copy(dAtA[i:], m.Disk)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Disk)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Memory != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x10
	}
	if m.CPU != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.CPU))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastTransitionTime != nil {
		{
			size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TriggeredBy) > 0 {
		i -= len(m.TriggeredBy)
		copy(dAtA[i:], m.TriggeredBy)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.TriggeredBy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotebook(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotebook(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateNotebookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Shutdown {
		n += 2
	}
	l = len(m.ShutdownBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	l = len(m.PausedBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CPU != 0 {
		n += 1 + sovNotebook(uint64(m.CPU))
	}
	if m.Memory != 0 {
		n += 1 + sovNotebook(uint64(m.Memory))
	}
	l = len(m.Disk)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status {
		n += 2
	}
	l = len(m.TriggeredBy)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotebook(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotebook(x uint64) (n int) {
	return sovNotebook(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNotebookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateNotebookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateNotebookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShutdownBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShutdownBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &Spec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			m.CPU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CPU |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &types.Timestamp{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotebook(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotebook
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotebook
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotebook
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotebook        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotebook          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotebook = fmt.Errorf("proto: unexpected end of group")
)
