// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: data.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A Deployment is represents one deployment of an ArangoDB cluster.
type Deployment struct {
	// System identifier of the deployment.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the deployment
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the deployment
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the project that owns this deployment.
	// After creation, this value cannot be changed.
	ProjectId string `protobuf:"bytes,5,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of the region in which the deployment is created.
	// After creation, this value cannot be changed.
	RegionId string `protobuf:"bytes,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The creation timestamp of the deployment
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the deployment
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,8,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this deployment is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,9,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// ArangoDB version to use for this deployment.
	// See Version.version.
	// If you change this value to a higher version,
	// the deployment will be upgraded.
	// If you change this value to a lower patch value,
	// the deployment will be downgraded.
	// Any attempt to change to a lower minor or major version
	// is considered an invalid request.
	// Any attempt to change to a version that is not in the
	// list of available versions is considered an invalid request.
	Version              string                         `protobuf:"bytes,101,opt,name=version,proto3" json:"version,omitempty"`
	Certificates         *Deployment_CertificateSpec    `protobuf:"bytes,102,opt,name=certificates,proto3" json:"certificates,omitempty"`
	Servers              *Deployment_ServersSpec        `protobuf:"bytes,103,opt,name=servers,proto3" json:"servers,omitempty"`
	Authentication       *Deployment_AuthenticationSpec `protobuf:"bytes,104,opt,name=authentication,proto3" json:"authentication,omitempty"`
	Status               *Deployment_Status             `protobuf:"bytes,201,opt,name=status,proto3" json:"status,omitempty"`
	Expiration           *Deployment_Expiration         `protobuf:"bytes,301,opt,name=expiration,proto3" json:"expiration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *Deployment) Reset()         { *m = Deployment{} }
func (m *Deployment) String() string { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()    {}
func (*Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0}
}
func (m *Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment.Merge(m, src)
}
func (m *Deployment) XXX_Size() int {
	return m.Size()
}
func (m *Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment proto.InternalMessageInfo

func (m *Deployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Deployment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Deployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Deployment) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Deployment) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *Deployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Deployment) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Deployment) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *Deployment) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Deployment) GetCertificates() *Deployment_CertificateSpec {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *Deployment) GetServers() *Deployment_ServersSpec {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Deployment) GetAuthentication() *Deployment_AuthenticationSpec {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *Deployment) GetStatus() *Deployment_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Deployment) GetExpiration() *Deployment_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

type Deployment_CertificateSpec struct {
	// Identifier of the CACertificate used to sign TLS certificates for the deployment.
	// If you change this value after the creation of the deployment a complete
	// rotation of the deployment is required, which will result in some downtime.
	CaCertificateId string `protobuf:"bytes,1,opt,name=ca_certificate_id,json=caCertificateId,proto3" json:"ca_certificate_id,omitempty"`
	// Zero or more DNS names to include in the TLS certificate of the deployment.
	AlternateDnsNames    []string `protobuf:"bytes,2,rep,name=alternate_dns_names,json=alternateDnsNames,proto3" json:"alternate_dns_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_CertificateSpec) Reset()         { *m = Deployment_CertificateSpec{} }
func (m *Deployment_CertificateSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_CertificateSpec) ProtoMessage()    {}
func (*Deployment_CertificateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 0}
}
func (m *Deployment_CertificateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_CertificateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_CertificateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_CertificateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_CertificateSpec.Merge(m, src)
}
func (m *Deployment_CertificateSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_CertificateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_CertificateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_CertificateSpec proto.InternalMessageInfo

func (m *Deployment_CertificateSpec) GetCaCertificateId() string {
	if m != nil {
		return m.CaCertificateId
	}
	return ""
}

func (m *Deployment_CertificateSpec) GetAlternateDnsNames() []string {
	if m != nil {
		return m.AlternateDnsNames
	}
	return nil
}

type Deployment_ServersSpec struct {
	// Number of coordinators of the deployment
	Coordinators int32 `protobuf:"varint,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for coordinators.
	CoordinatorMemorySize int32 `protobuf:"varint,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Custom command line arguments passed to all coordinators.
	CoordinatorArgs []string `protobuf:"bytes,3,rep,name=coordinator_args,json=coordinatorArgs,proto3" json:"coordinator_args,omitempty"`
	// Number of dbservers of the deployment
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for dbservers.
	DbserverMemorySize int32 `protobuf:"varint,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for dbservers.
	DbserverDiskSize int32 `protobuf:"varint,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Custom command line arguments passed to all dbservers.
	DbserverArgs         []string `protobuf:"bytes,14,rep,name=dbserver_args,json=dbserverArgs,proto3" json:"dbserver_args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_ServersSpec) Reset()         { *m = Deployment_ServersSpec{} }
func (m *Deployment_ServersSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_ServersSpec) ProtoMessage()    {}
func (*Deployment_ServersSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 1}
}
func (m *Deployment_ServersSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_ServersSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_ServersSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_ServersSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_ServersSpec.Merge(m, src)
}
func (m *Deployment_ServersSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_ServersSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_ServersSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_ServersSpec proto.InternalMessageInfo

func (m *Deployment_ServersSpec) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *Deployment_ServersSpec) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetCoordinatorArgs() []string {
	if m != nil {
		return m.CoordinatorArgs
	}
	return nil
}

func (m *Deployment_ServersSpec) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverArgs() []string {
	if m != nil {
		return m.DbserverArgs
	}
	return nil
}

type Deployment_AuthenticationSpec struct {
	// Password of the root user of the deployment.
	RootPassword         string   `protobuf:"bytes,1,opt,name=root_password,json=rootPassword,proto3" json:"root_password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_AuthenticationSpec) Reset()         { *m = Deployment_AuthenticationSpec{} }
func (m *Deployment_AuthenticationSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_AuthenticationSpec) ProtoMessage()    {}
func (*Deployment_AuthenticationSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 2}
}
func (m *Deployment_AuthenticationSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_AuthenticationSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_AuthenticationSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_AuthenticationSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_AuthenticationSpec.Merge(m, src)
}
func (m *Deployment_AuthenticationSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_AuthenticationSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_AuthenticationSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_AuthenticationSpec proto.InternalMessageInfo

func (m *Deployment_AuthenticationSpec) GetRootPassword() string {
	if m != nil {
		return m.RootPassword
	}
	return ""
}

// Status of a single server (of the ArangoDB cluster)
type Deployment_ServerStatus struct {
	// ID of the server
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type of server (agent|coordinator|dbserver)
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Human readable description of the status of the deployment.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The creation timestamp of the server
	CreatedAt *types.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Set once the server is ready
	Ready bool `protobuf:"varint,5,opt,name=ready,proto3" json:"ready,omitempty"`
	// Set once the server has been known to be a member of the cluster
	MemberOfCluster bool `protobuf:"varint,6,opt,name=member_of_cluster,json=memberOfCluster,proto3" json:"member_of_cluster,omitempty"`
	// Set if the server is in a failed state
	Failed               bool     `protobuf:"varint,7,opt,name=failed,proto3" json:"failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_ServerStatus) Reset()         { *m = Deployment_ServerStatus{} }
func (m *Deployment_ServerStatus) String() string { return proto.CompactTextString(m) }
func (*Deployment_ServerStatus) ProtoMessage()    {}
func (*Deployment_ServerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 3}
}
func (m *Deployment_ServerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_ServerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_ServerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_ServerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_ServerStatus.Merge(m, src)
}
func (m *Deployment_ServerStatus) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_ServerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_ServerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_ServerStatus proto.InternalMessageInfo

func (m *Deployment_ServerStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Deployment_ServerStatus) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Deployment_ServerStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment_ServerStatus) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Deployment_ServerStatus) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *Deployment_ServerStatus) GetMemberOfCluster() bool {
	if m != nil {
		return m.MemberOfCluster
	}
	return false
}

func (m *Deployment_ServerStatus) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

// Status of the deployment
// All members of this field are read-only.
type Deployment_Status struct {
	// Endpoint URL used to reach the deployment
	// This value will be empty during the creation of the deployment.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Human readable description of the status of the deployment.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Set once the deployment has been created.
	Created bool `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
	// Set if the deployment is ready to be used.
	// If the deployment has downtime (e.g. because of changing a CA certificate)
	// this will go to false until the downtime is over.
	Ready bool `protobuf:"varint,4,opt,name=ready,proto3" json:"ready,omitempty"`
	// Set if the deployment is being upgraded.
	Upgrading bool `protobuf:"varint,5,opt,name=upgrading,proto3" json:"upgrading,omitempty"`
	// Versions of running servers
	ServerVersions []string `protobuf:"bytes,6,rep,name=server_versions,json=serverVersions,proto3" json:"server_versions,omitempty"`
	// Status of individual servers of the deployment
	Servers              []*Deployment_ServerStatus `protobuf:"bytes,7,rep,name=servers,proto3" json:"servers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Deployment_Status) Reset()         { *m = Deployment_Status{} }
func (m *Deployment_Status) String() string { return proto.CompactTextString(m) }
func (*Deployment_Status) ProtoMessage()    {}
func (*Deployment_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 4}
}
func (m *Deployment_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_Status.Merge(m, src)
}
func (m *Deployment_Status) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_Status proto.InternalMessageInfo

func (m *Deployment_Status) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Deployment_Status) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment_Status) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

func (m *Deployment_Status) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *Deployment_Status) GetUpgrading() bool {
	if m != nil {
		return m.Upgrading
	}
	return false
}

func (m *Deployment_Status) GetServerVersions() []string {
	if m != nil {
		return m.ServerVersions
	}
	return nil
}

func (m *Deployment_Status) GetServers() []*Deployment_ServerStatus {
	if m != nil {
		return m.Servers
	}
	return nil
}

// Expiration of the deployment.
// All members of this message are read-only.
type Deployment_Expiration struct {
	// The expiration timestamp of the deployment
	// If not set, the deployment will not expire.
	ExpiresAt *types.Timestamp `protobuf:"bytes,1,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Human readable reason for why the deployment expires (or does not expire).
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// The timestamp of when the last "this deployment will expire at" email was
	// send.
	// If not set, no such email has been send.
	LastWarningEmailSendAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_warning_email_send_at,json=lastWarningEmailSendAt,proto3" json:"last_warning_email_send_at,omitempty"`
	// List of email addresses to which the last warning email has been send.
	// Not set when no such email has been send.
	LastWarningEmailSendTo []string `protobuf:"bytes,4,rep,name=last_warning_email_send_to,json=lastWarningEmailSendTo,proto3" json:"last_warning_email_send_to,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Deployment_Expiration) Reset()         { *m = Deployment_Expiration{} }
func (m *Deployment_Expiration) String() string { return proto.CompactTextString(m) }
func (*Deployment_Expiration) ProtoMessage()    {}
func (*Deployment_Expiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0, 5}
}
func (m *Deployment_Expiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_Expiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_Expiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_Expiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_Expiration.Merge(m, src)
}
func (m *Deployment_Expiration) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_Expiration) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_Expiration.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_Expiration proto.InternalMessageInfo

func (m *Deployment_Expiration) GetExpiresAt() *types.Timestamp {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *Deployment_Expiration) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Deployment_Expiration) GetLastWarningEmailSendAt() *types.Timestamp {
	if m != nil {
		return m.LastWarningEmailSendAt
	}
	return nil
}

func (m *Deployment_Expiration) GetLastWarningEmailSendTo() []string {
	if m != nil {
		return m.LastWarningEmailSendTo
	}
	return nil
}

// Request arguments for ListServersSpecPresets and GetDefaultServersSpecPreset
type ServersSpecPresetsRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of a region in which a deployment will be created.
	RegionId             string   `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServersSpecPresetsRequest) Reset()         { *m = ServersSpecPresetsRequest{} }
func (m *ServersSpecPresetsRequest) String() string { return proto.CompactTextString(m) }
func (*ServersSpecPresetsRequest) ProtoMessage()    {}
func (*ServersSpecPresetsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{1}
}
func (m *ServersSpecPresetsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecPresetsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecPresetsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecPresetsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecPresetsRequest.Merge(m, src)
}
func (m *ServersSpecPresetsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecPresetsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecPresetsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecPresetsRequest proto.InternalMessageInfo

func (m *ServersSpecPresetsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ServersSpecPresetsRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

// Specification of a ServersSpecPreset, which can be used to initialize a deployment.servers
type ServersSpecPreset struct {
	// Name of the ServersSpecPreset
	// This is a read-only value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Set when this preset is the default.
	// This is a read-only value.
	IsDefault bool `protobuf:"varint,2,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
	// The ServersSpec associated for this name
	Servers              *Deployment_ServersSpec `protobuf:"bytes,3,opt,name=servers,proto3" json:"servers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ServersSpecPreset) Reset()         { *m = ServersSpecPreset{} }
func (m *ServersSpecPreset) String() string { return proto.CompactTextString(m) }
func (*ServersSpecPreset) ProtoMessage()    {}
func (*ServersSpecPreset) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{2}
}
func (m *ServersSpecPreset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecPreset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecPreset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecPreset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecPreset.Merge(m, src)
}
func (m *ServersSpecPreset) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecPreset) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecPreset.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecPreset proto.InternalMessageInfo

func (m *ServersSpecPreset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServersSpecPreset) GetIsDefault() bool {
	if m != nil {
		return m.IsDefault
	}
	return false
}

func (m *ServersSpecPreset) GetServers() *Deployment_ServersSpec {
	if m != nil {
		return m.Servers
	}
	return nil
}

// List of ServersSpecPreset.
type ServersSpecPresetList struct {
	Items                []*ServersSpecPreset `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ServersSpecPresetList) Reset()         { *m = ServersSpecPresetList{} }
func (m *ServersSpecPresetList) String() string { return proto.CompactTextString(m) }
func (*ServersSpecPresetList) ProtoMessage()    {}
func (*ServersSpecPresetList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{3}
}
func (m *ServersSpecPresetList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecPresetList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecPresetList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecPresetList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecPresetList.Merge(m, src)
}
func (m *ServersSpecPresetList) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecPresetList) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecPresetList.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecPresetList proto.InternalMessageInfo

func (m *ServersSpecPresetList) GetItems() []*ServersSpecPreset {
	if m != nil {
		return m.Items
	}
	return nil
}

// List of Deployments.
type DeploymentList struct {
	// Actual deployments
	Items []*Deployment `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Budget for deployments
	Budget               *v1.Budget `protobuf:"bytes,2,opt,name=budget,proto3" json:"budget,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeploymentList) Reset()         { *m = DeploymentList{} }
func (m *DeploymentList) String() string { return proto.CompactTextString(m) }
func (*DeploymentList) ProtoMessage()    {}
func (*DeploymentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4}
}
func (m *DeploymentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentList.Merge(m, src)
}
func (m *DeploymentList) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentList) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentList.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentList proto.InternalMessageInfo

func (m *DeploymentList) GetItems() []*Deployment {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *DeploymentList) GetBudget() *v1.Budget {
	if m != nil {
		return m.Budget
	}
	return nil
}

// Version of an ArangoDB release
type Version struct {
	// Version in the format of major.minor.patch
	Version              string   `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{5}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// List of Versions.
type VersionList struct {
	Items                []*Version `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VersionList) Reset()         { *m = VersionList{} }
func (m *VersionList) String() string { return proto.CompactTextString(m) }
func (*VersionList) ProtoMessage()    {}
func (*VersionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{6}
}
func (m *VersionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionList.Merge(m, src)
}
func (m *VersionList) XXX_Size() int {
	return m.Size()
}
func (m *VersionList) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionList.DiscardUnknown(m)
}

var xxx_messageInfo_VersionList proto.InternalMessageInfo

func (m *VersionList) GetItems() []*Version {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListVersions.
type ListVersionsRequest struct {
	// Common list options
	Options *v1.ListOptions `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	// If set, the result includes all versions for that are available for the
	// organization identified by this ID.
	// If not set, only versions are returned that are available to all organizations.
	OrganizationId       string   `protobuf:"bytes,2,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListVersionsRequest) Reset()         { *m = ListVersionsRequest{} }
func (m *ListVersionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListVersionsRequest) ProtoMessage()    {}
func (*ListVersionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{7}
}
func (m *ListVersionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListVersionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListVersionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListVersionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVersionsRequest.Merge(m, src)
}
func (m *ListVersionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListVersionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVersionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListVersionsRequest proto.InternalMessageInfo

func (m *ListVersionsRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListVersionsRequest) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

// Request arguments for ListServersSpecLimits
type ServersSpecLimitsRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of a region in which a deployment will be created.
	RegionId             string   `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServersSpecLimitsRequest) Reset()         { *m = ServersSpecLimitsRequest{} }
func (m *ServersSpecLimitsRequest) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimitsRequest) ProtoMessage()    {}
func (*ServersSpecLimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{8}
}
func (m *ServersSpecLimitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimitsRequest.Merge(m, src)
}
func (m *ServersSpecLimitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimitsRequest proto.InternalMessageInfo

func (m *ServersSpecLimitsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ServersSpecLimitsRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

// Limits of allowed values for fields of Deployment.ServersSpec.
type ServersSpecLimits struct {
	// Limits for the number of coordinators of the deployment
	Coordinators *ServersSpecLimits_Limits `protobuf:"bytes,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Possible values for the amount of memory (in GB) to allocate
	// for coordinators.
	CoordinatorMemorySize *ServersSpecLimits_Limits `protobuf:"bytes,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Limits for the number of dbservers of the deployment
	Dbservers *ServersSpecLimits_Limits `protobuf:"bytes,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Possible values for the amount of memory (in GB) to allocate
	// for dbservers.
	DbserverMemorySize *ServersSpecLimits_Limits `protobuf:"bytes,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for dbservers.
	DbserverDiskSize     *ServersSpecLimits_Limits `protobuf:"bytes,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ServersSpecLimits) Reset()         { *m = ServersSpecLimits{} }
func (m *ServersSpecLimits) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimits) ProtoMessage()    {}
func (*ServersSpecLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{9}
}
func (m *ServersSpecLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimits.Merge(m, src)
}
func (m *ServersSpecLimits) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimits.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimits proto.InternalMessageInfo

func (m *ServersSpecLimits) GetCoordinators() *ServersSpecLimits_Limits {
	if m != nil {
		return m.Coordinators
	}
	return nil
}

func (m *ServersSpecLimits) GetCoordinatorMemorySize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return nil
}

func (m *ServersSpecLimits) GetDbservers() *ServersSpecLimits_Limits {
	if m != nil {
		return m.Dbservers
	}
	return nil
}

func (m *ServersSpecLimits) GetDbserverMemorySize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.DbserverMemorySize
	}
	return nil
}

func (m *ServersSpecLimits) GetDbserverDiskSize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.DbserverDiskSize
	}
	return nil
}

type ServersSpecLimits_Limits struct {
	// Minimum value
	Min int32 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	// Maximum value
	Max int32 `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	// Set of allowed values.
	// If this field is non-empty, only one of these values
	// is allowed.
	AllowedValues        []int32  `protobuf:"varint,3,rep,packed,name=allowed_values,json=allowedValues,proto3" json:"allowed_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServersSpecLimits_Limits) Reset()         { *m = ServersSpecLimits_Limits{} }
func (m *ServersSpecLimits_Limits) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimits_Limits) ProtoMessage()    {}
func (*ServersSpecLimits_Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{9, 0}
}
func (m *ServersSpecLimits_Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimits_Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimits_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimits_Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimits_Limits.Merge(m, src)
}
func (m *ServersSpecLimits_Limits) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimits_Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimits_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimits_Limits proto.InternalMessageInfo

func (m *ServersSpecLimits_Limits) GetMin() int32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *ServersSpecLimits_Limits) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *ServersSpecLimits_Limits) GetAllowedValues() []int32 {
	if m != nil {
		return m.AllowedValues
	}
	return nil
}

func init() {
	proto.RegisterType((*Deployment)(nil), "arangodb.cloud.data.v1.Deployment")
	proto.RegisterType((*Deployment_CertificateSpec)(nil), "arangodb.cloud.data.v1.Deployment.CertificateSpec")
	proto.RegisterType((*Deployment_ServersSpec)(nil), "arangodb.cloud.data.v1.Deployment.ServersSpec")
	proto.RegisterType((*Deployment_AuthenticationSpec)(nil), "arangodb.cloud.data.v1.Deployment.AuthenticationSpec")
	proto.RegisterType((*Deployment_ServerStatus)(nil), "arangodb.cloud.data.v1.Deployment.ServerStatus")
	proto.RegisterType((*Deployment_Status)(nil), "arangodb.cloud.data.v1.Deployment.Status")
	proto.RegisterType((*Deployment_Expiration)(nil), "arangodb.cloud.data.v1.Deployment.Expiration")
	proto.RegisterType((*ServersSpecPresetsRequest)(nil), "arangodb.cloud.data.v1.ServersSpecPresetsRequest")
	proto.RegisterType((*ServersSpecPreset)(nil), "arangodb.cloud.data.v1.ServersSpecPreset")
	proto.RegisterType((*ServersSpecPresetList)(nil), "arangodb.cloud.data.v1.ServersSpecPresetList")
	proto.RegisterType((*DeploymentList)(nil), "arangodb.cloud.data.v1.DeploymentList")
	proto.RegisterType((*Version)(nil), "arangodb.cloud.data.v1.Version")
	proto.RegisterType((*VersionList)(nil), "arangodb.cloud.data.v1.VersionList")
	proto.RegisterType((*ListVersionsRequest)(nil), "arangodb.cloud.data.v1.ListVersionsRequest")
	proto.RegisterType((*ServersSpecLimitsRequest)(nil), "arangodb.cloud.data.v1.ServersSpecLimitsRequest")
	proto.RegisterType((*ServersSpecLimits)(nil), "arangodb.cloud.data.v1.ServersSpecLimits")
	proto.RegisterType((*ServersSpecLimits_Limits)(nil), "arangodb.cloud.data.v1.ServersSpecLimits.Limits")
}

func init() { proto.RegisterFile("data.proto", fileDescriptor_871986018790d2fd) }

var fileDescriptor_871986018790d2fd = []byte{
	// 1596 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6f, 0xdb, 0x46,
	0x16, 0x5f, 0x4a, 0xb6, 0x2c, 0x3d, 0xf9, 0xef, 0x24, 0x71, 0xb8, 0xda, 0xc4, 0x31, 0x64, 0x64,
	0xd7, 0xc9, 0xae, 0xc5, 0x58, 0x8b, 0x04, 0x49, 0x16, 0xbb, 0x59, 0x27, 0x76, 0x53, 0x03, 0x69,
	0x12, 0xd0, 0xa9, 0x53, 0x14, 0x68, 0x89, 0x91, 0x38, 0xa6, 0xa7, 0x21, 0x39, 0x2c, 0x67, 0xe4,
	0xc4, 0x71, 0x03, 0x03, 0x45, 0x0e, 0x3d, 0x16, 0x68, 0x0f, 0xf9, 0x12, 0x3d, 0x16, 0x05, 0x8a,
	0x9e, 0x7a, 0x6a, 0x6e, 0x05, 0xfa, 0x05, 0x8a, 0xb4, 0x97, 0x9e, 0xfb, 0x05, 0x8a, 0x19, 0x0e,
	0x25, 0xca, 0xb2, 0x2c, 0xc5, 0x6d, 0x6f, 0x9c, 0x37, 0xef, 0xf7, 0xe6, 0xf7, 0xde, 0xbc, 0x79,
	0xef, 0x49, 0x00, 0x2e, 0x16, 0xb8, 0x16, 0xc5, 0x4c, 0x30, 0x34, 0x8b, 0x63, 0x1c, 0x7a, 0xcc,
	0x6d, 0xd4, 0x9a, 0x3e, 0x6b, 0xb9, 0x35, 0xb5, 0xb5, 0xb3, 0x5c, 0x99, 0x6d, 0xb2, 0x20, 0x60,
	0xa1, 0xb5, 0xb3, 0x6c, 0x25, 0x5f, 0x89, 0x7e, 0xe5, 0x3f, 0x1e, 0x15, 0xdb, 0xad, 0x46, 0xad,
	0xc9, 0x02, 0xcb, 0x63, 0x3e, 0x0e, 0x3d, 0x4b, 0x6d, 0x34, 0x5a, 0x5b, 0x56, 0x24, 0x76, 0x23,
	0xc2, 0x2d, 0x41, 0x03, 0xc2, 0x05, 0x0e, 0xa2, 0xce, 0x97, 0x06, 0x9f, 0xf1, 0x18, 0xf3, 0x7c,
	0x62, 0xe1, 0x88, 0x5a, 0x38, 0x0c, 0x99, 0xc0, 0x82, 0xb2, 0x90, 0x27, 0xbb, 0xd5, 0x2f, 0xa7,
	0x00, 0x56, 0x49, 0xe4, 0xb3, 0xdd, 0x80, 0x84, 0x02, 0x4d, 0x42, 0x8e, 0xba, 0xa6, 0x31, 0x6f,
	0x2c, 0x96, 0xec, 0x1c, 0x75, 0xd1, 0x34, 0xe4, 0x5b, 0xb1, 0x6f, 0xe6, 0x94, 0x40, 0x7e, 0x22,
	0x04, 0x23, 0x21, 0x0e, 0x88, 0x99, 0x57, 0x22, 0xf5, 0x8d, 0xe6, 0xa1, 0xec, 0x12, 0xde, 0x8c,
	0x69, 0x24, 0x4d, 0x9b, 0x23, 0x6a, 0x2b, 0x2b, 0x42, 0x67, 0x01, 0xa2, 0x98, 0x7d, 0x40, 0x9a,
	0xc2, 0xa1, 0xae, 0x39, 0xaa, 0x14, 0x4a, 0x5a, 0xb2, 0xee, 0xa2, 0xbf, 0x41, 0x29, 0x26, 0x1e,
	0x65, 0xa1, 0xdc, 0x2d, 0xa8, 0xdd, 0x62, 0x22, 0x58, 0x77, 0xd1, 0x35, 0x80, 0x66, 0x4c, 0xb0,
	0x20, 0xae, 0x83, 0x85, 0x39, 0x36, 0x6f, 0x2c, 0x96, 0xeb, 0x95, 0x5a, 0xe2, 0x55, 0x2d, 0x8d,
	0x43, 0xed, 0x41, 0xea, 0xb6, 0x5d, 0xd2, 0xda, 0x2b, 0x42, 0x42, 0x5d, 0xe2, 0x13, 0x0d, 0x2d,
	0x0e, 0x86, 0x6a, 0xed, 0x15, 0x21, 0x19, 0x53, 0xee, 0xe8, 0xb5, 0x59, 0x9a, 0x37, 0x16, 0x8b,
	0x76, 0x89, 0xf2, 0xd5, 0x44, 0x80, 0x4c, 0x18, 0xdb, 0x21, 0x31, 0x97, 0xee, 0x12, 0xc5, 0x37,
	0x5d, 0xa2, 0x4d, 0x18, 0x6f, 0x92, 0x58, 0xd0, 0x2d, 0xda, 0xc4, 0x82, 0x70, 0x73, 0x4b, 0x9d,
	0x5a, 0xaf, 0x1d, 0x7e, 0xe7, 0xb5, 0x4e, 0xf0, 0x6b, 0xb7, 0x3a, 0xb0, 0x8d, 0x88, 0x34, 0xed,
	0x2e, 0x3b, 0xe8, 0x4d, 0x18, 0xe3, 0x24, 0x96, 0xa7, 0x98, 0x9e, 0x32, 0x59, 0x1b, 0xc2, 0xe4,
	0x46, 0x82, 0x50, 0xe6, 0x52, 0x38, 0x7a, 0x0f, 0x26, 0x71, 0x4b, 0x6c, 0x93, 0x50, 0x48, 0xd3,
	0xd2, 0x85, 0x6d, 0x65, 0xf0, 0xf2, 0x10, 0x06, 0x57, 0xba, 0x80, 0xca, 0xee, 0x01, 0x63, 0xe8,
	0x26, 0x14, 0xb8, 0xc0, 0xa2, 0xc5, 0xcd, 0x97, 0x86, 0xb2, 0x7b, 0x61, 0x18, 0xa2, 0x0a, 0x61,
	0x6b, 0x24, 0xba, 0x0b, 0x40, 0x9e, 0x44, 0x34, 0x4e, 0xe8, 0x7d, 0x91, 0x53, 0x76, 0x96, 0x86,
	0xb0, 0xb3, 0xd6, 0x46, 0xd9, 0x19, 0x0b, 0x95, 0x00, 0xa6, 0x0e, 0x44, 0x17, 0x5d, 0x84, 0x99,
	0x26, 0x76, 0x32, 0x21, 0x76, 0xda, 0x99, 0x3f, 0xd5, 0xc4, 0x19, 0xed, 0x75, 0x17, 0xd5, 0xe0,
	0x04, 0xf6, 0x05, 0x89, 0x43, 0xa9, 0xe6, 0x86, 0xdc, 0x91, 0x69, 0xcf, 0xcd, 0xdc, 0x7c, 0x7e,
	0xb1, 0x64, 0xcf, 0xb4, 0xb7, 0x56, 0x43, 0x7e, 0x57, 0x6e, 0x54, 0xbe, 0xca, 0x41, 0x39, 0x13,
	0x7a, 0x54, 0x85, 0xf1, 0x26, 0x63, 0xb1, 0x4b, 0x43, 0x2c, 0x58, 0xcc, 0xd5, 0x31, 0xa3, 0x76,
	0x97, 0x0c, 0x5d, 0x81, 0xd3, 0x99, 0xb5, 0x13, 0x90, 0x80, 0xc5, 0xbb, 0x0e, 0xa7, 0x4f, 0x89,
	0x7a, 0x7e, 0xa3, 0xf6, 0xa9, 0xcc, 0xf6, 0x5b, 0x6a, 0x77, 0x83, 0x3e, 0x25, 0xe8, 0x02, 0x4c,
	0x67, 0x71, 0x38, 0xf6, 0xb8, 0x99, 0x57, 0xc4, 0xa6, 0x32, 0xf2, 0x95, 0xd8, 0xe3, 0xe8, 0x0c,
	0x94, 0xdc, 0x46, 0x9a, 0x44, 0x65, 0x65, 0xb4, 0x23, 0x40, 0x97, 0xe0, 0x64, 0xba, 0xe8, 0x3a,
	0x7d, 0x5c, 0x29, 0xa2, 0x74, 0x2f, 0x73, 0xf4, 0xbf, 0xa0, 0x2d, 0x75, 0x5c, 0xca, 0x1f, 0x25,
	0xfa, 0x13, 0x4a, 0x7f, 0x3a, 0xdd, 0x59, 0xa5, 0xfc, 0x91, 0xd2, 0x5e, 0x80, 0x89, 0xb6, 0xb6,
	0x62, 0x39, 0xa9, 0x58, 0x8e, 0xa7, 0x42, 0x49, 0xb1, 0x72, 0x0d, 0x50, 0x6f, 0x8a, 0x49, 0x68,
	0xcc, 0x98, 0x70, 0x22, 0xcc, 0xf9, 0x63, 0x16, 0xa7, 0xf7, 0x34, 0x2e, 0x85, 0xf7, 0xb5, 0xac,
	0xf2, 0x8b, 0x01, 0xe3, 0x49, 0xd0, 0x93, 0x64, 0xea, 0x29, 0x66, 0x08, 0x46, 0x64, 0xb1, 0xd4,
	0xd5, 0x4c, 0x7d, 0x1f, 0x2c, 0x5d, 0xf9, 0xde, 0xd2, 0xd5, 0x5d, 0x7e, 0x46, 0x5e, 0xa7, 0xfc,
	0x9c, 0x84, 0xd1, 0x98, 0x60, 0x77, 0x57, 0x15, 0xbc, 0xa2, 0x9d, 0x2c, 0x64, 0xe2, 0x05, 0x24,
	0x68, 0x90, 0xd8, 0x61, 0x5b, 0x4e, 0xd3, 0x6f, 0x71, 0x41, 0x62, 0x55, 0xf4, 0x8a, 0xf6, 0x54,
	0xb2, 0x71, 0x6f, 0xeb, 0x56, 0x22, 0x46, 0xb3, 0x50, 0xd8, 0xc2, 0xd4, 0x27, 0xae, 0xaa, 0x7b,
	0x45, 0x5b, 0xaf, 0x2a, 0x9f, 0xe4, 0xa0, 0xa0, 0xbd, 0xac, 0x40, 0x91, 0x84, 0x6e, 0xc4, 0x68,
	0x28, 0xb4, 0xaf, 0xed, 0xf5, 0x41, 0xef, 0x72, 0xbd, 0xde, 0x99, 0x30, 0xa6, 0xf9, 0x2a, 0xdf,
	0x8b, 0x76, 0xba, 0xec, 0x90, 0x1f, 0xc9, 0x92, 0x3f, 0x03, 0xa5, 0x56, 0xe4, 0xc5, 0xd8, 0xa5,
	0xa1, 0xa7, 0xdd, 0xea, 0x08, 0xd0, 0x3f, 0x60, 0x4a, 0x5f, 0xb0, 0xae, 0x86, 0xdc, 0x2c, 0xa8,
	0x4b, 0x9e, 0x4c, 0xc4, 0x9b, 0x5a, 0x8a, 0xd6, 0x3b, 0xc5, 0x6c, 0x6c, 0x3e, 0xbf, 0x58, 0xae,
	0x5b, 0x43, 0x17, 0x33, 0x5d, 0x29, 0x52, 0x7c, 0xe5, 0x57, 0x03, 0xa0, 0xf3, 0xea, 0xe5, 0x75,
	0xa9, 0x77, 0x4f, 0xb8, 0xbc, 0x2e, 0x63, 0xf0, 0x75, 0x69, 0xed, 0x15, 0x21, 0x83, 0x1d, 0x13,
	0xcc, 0xdb, 0x81, 0xd2, 0x2b, 0xb4, 0x09, 0x15, 0x1f, 0x73, 0xe1, 0x3c, 0xc6, 0x71, 0x48, 0x43,
	0xcf, 0x21, 0x01, 0xa6, 0xbe, 0xc3, 0x49, 0xa8, 0x32, 0x22, 0x3f, 0xf0, 0x88, 0x59, 0x89, 0x7e,
	0x98, 0x80, 0xd7, 0x24, 0x76, 0x83, 0x84, 0x32, 0x3d, 0xae, 0xf7, 0xb7, 0x2b, 0x98, 0x39, 0xa2,
	0x02, 0x77, 0x28, 0xf6, 0x01, 0xab, 0x3e, 0x84, 0xbf, 0x66, 0x0a, 0xcc, 0xfd, 0x98, 0x70, 0x22,
	0xb8, 0x4d, 0x3e, 0x6c, 0x11, 0x2e, 0x0e, 0x74, 0x5b, 0xe3, 0xc8, 0x6e, 0x9b, 0xeb, 0xee, 0xb6,
	0xd5, 0x4f, 0x0d, 0x98, 0xe9, 0xb1, 0xdc, 0xee, 0xfa, 0x46, 0xa6, 0xeb, 0xa7, 0x1d, 0x72, 0x0b,
	0xb7, 0x7c, 0xa1, 0xec, 0xe8, 0x0e, 0xa9, 0x04, 0xd9, 0x7e, 0x95, 0xff, 0x5d, 0xfd, 0xaa, 0xfa,
	0x0e, 0x9c, 0xea, 0x61, 0x74, 0x87, 0x72, 0x81, 0x6e, 0xc0, 0x28, 0x15, 0x24, 0x90, 0xf5, 0x34,
	0x7f, 0x54, 0x9f, 0xe9, 0x41, 0xdb, 0x09, 0xae, 0xfa, 0xdc, 0x80, 0xc9, 0xce, 0xe9, 0xca, 0xe6,
	0xd5, 0x6e, 0x9b, 0xd5, 0xc1, 0xa4, 0xb5, 0x31, 0x74, 0x15, 0x0a, 0x8d, 0x96, 0xeb, 0x91, 0x24,
	0x16, 0xe5, 0xfa, 0xfc, 0x41, 0xa8, 0x9e, 0xe9, 0x76, 0x96, 0x6b, 0x37, 0x95, 0x9e, 0xad, 0xf5,
	0xab, 0x0b, 0x30, 0xa6, 0x5f, 0x46, 0x76, 0xae, 0x30, 0xba, 0xe6, 0x8a, 0xea, 0x2a, 0x94, 0xb5,
	0x92, 0xe2, 0x79, 0xb9, 0x9b, 0xe7, 0xb9, 0x7e, 0x3c, 0x35, 0x26, 0xf5, 0x78, 0x1f, 0x4e, 0x48,
	0x78, 0xfa, 0x10, 0xd3, 0x8c, 0xb9, 0x01, 0x63, 0x4c, 0x15, 0x04, 0xae, 0x9f, 0xcc, 0xf9, 0xfe,
	0xe4, 0x25, 0xfe, 0x5e, 0xa2, 0x6c, 0xa7, 0x28, 0xf9, 0xf2, 0x59, 0xec, 0xe1, 0x90, 0x3e, 0x55,
	0xcf, 0xb0, 0x93, 0x59, 0x93, 0x59, 0xf1, 0xba, 0x5b, 0xdd, 0x04, 0x33, 0x73, 0x1d, 0x77, 0x68,
	0x40, 0xff, 0x98, 0xbc, 0xfd, 0x66, 0xa4, 0x2b, 0x6f, 0x13, 0xc3, 0xe8, 0xc1, 0x21, 0x8d, 0xb7,
	0x5c, 0xbf, 0x34, 0x44, 0xa2, 0x24, 0x06, 0x6a, 0x9a, 0x60, 0x77, 0xab, 0xde, 0x3e, 0xba, 0x55,
	0x1f, 0xe7, 0x80, 0x3e, 0xcd, 0xfd, 0xee, 0xc1, 0x8e, 0x7d, 0x1c, 0xdb, 0x99, 0x1e, 0xdf, 0x38,
	0xa2, 0xc7, 0x1f, 0xc7, 0xf4, 0x61, 0x53, 0xc1, 0xfb, 0x7d, 0xa7, 0x82, 0xe3, 0x9c, 0xd0, 0x33,
	0x47, 0x54, 0x36, 0xa0, 0xa0, 0x6f, 0x77, 0x1a, 0xf2, 0x01, 0x0d, 0xf5, 0x34, 0x25, 0x3f, 0x95,
	0x04, 0x3f, 0xd1, 0x03, 0x93, 0xfc, 0x44, 0xe7, 0x61, 0x12, 0xfb, 0x3e, 0x7b, 0x4c, 0x5c, 0x67,
	0x07, 0xfb, 0x2d, 0x92, 0x0c, 0x47, 0xa3, 0xf6, 0x84, 0x96, 0x6e, 0x2a, 0x61, 0xfd, 0x25, 0x40,
	0x79, 0x15, 0x0b, 0x2c, 0x79, 0xd0, 0x26, 0x41, 0x2f, 0x0c, 0x98, 0x92, 0x89, 0xde, 0x79, 0xe6,
	0x1c, 0x0d, 0xf7, 0x26, 0x2a, 0x7f, 0x1f, 0x5c, 0x32, 0xa4, 0x7a, 0xf5, 0xca, 0xc7, 0x3f, 0xfc,
	0xfc, 0x59, 0xee, 0x12, 0xaa, 0xa9, 0x9f, 0x66, 0x52, 0x49, 0xfe, 0xf0, 0xd3, 0xe9, 0xce, 0xad,
	0xbd, 0x26, 0x0b, 0x05, 0x79, 0x22, 0x9f, 0xc2, 0x33, 0xcb, 0xcd, 0xd0, 0xd8, 0x87, 0x89, 0xdb,
	0x24, 0x43, 0x0c, 0x2d, 0xf4, 0xe7, 0xb5, 0xbe, 0x9a, 0xb2, 0x1a, 0xa2, 0x90, 0x55, 0xcf, 0x2b,
	0x46, 0xe7, 0xd0, 0xd9, 0x2e, 0x46, 0x99, 0xb3, 0xad, 0x3d, 0xea, 0x3e, 0x43, 0x9f, 0x1b, 0x30,
	0x7d, 0x4b, 0x4d, 0x09, 0x19, 0x12, 0x43, 0xd8, 0x1f, 0x8a, 0xc3, 0x55, 0xc5, 0xa1, 0x5e, 0x5d,
	0x3a, 0x2c, 0x2a, 0xd6, 0x5e, 0xa7, 0x3e, 0x74, 0x05, 0xe5, 0xba, 0x71, 0x11, 0x3d, 0x37, 0x60,
	0xfa, 0xed, 0xc8, 0xfd, 0x73, 0x68, 0x2d, 0x2a, 0x5a, 0xd5, 0xfa, 0xd1, 0xa1, 0x91, 0x34, 0xf6,
	0x61, 0x3a, 0xf9, 0x91, 0xf8, 0xba, 0x37, 0x74, 0xae, 0xbf, 0xd2, 0x5a, 0x10, 0x89, 0xdd, 0xf4,
	0x7a, 0x2e, 0x0e, 0xb8, 0x9e, 0x7d, 0x18, 0xcf, 0x96, 0x78, 0xf4, 0xcf, 0x7e, 0xee, 0x1d, 0xd2,
	0x08, 0x2a, 0x0b, 0x03, 0xfa, 0x88, 0xca, 0xdc, 0xb3, 0x8a, 0xc8, 0x69, 0x74, 0xaa, 0x8b, 0x48,
	0x3a, 0xf2, 0xa1, 0x8f, 0x60, 0x46, 0x25, 0xa8, 0x9a, 0x03, 0xd2, 0xc6, 0x36, 0xc8, 0xbb, 0xca,
	0xa0, 0x0e, 0xd6, 0x27, 0x3b, 0xd3, 0x53, 0x2d, 0x3d, 0x88, 0xa0, 0xaf, 0x0d, 0x38, 0x79, 0x9b,
	0x88, 0xde, 0x5e, 0x30, 0x7c, 0xed, 0x49, 0x83, 0x71, 0x61, 0x68, 0x44, 0x75, 0x4d, 0x91, 0xbb,
	0x81, 0xfe, 0xdb, 0xe7, 0x31, 0x67, 0xf3, 0x36, 0xe9, 0x59, 0xdc, 0xda, 0x6b, 0x77, 0xb3, 0x67,
	0x96, 0x9f, 0x70, 0xfc, 0xd6, 0x80, 0x59, 0x19, 0xe2, 0xde, 0xd9, 0x0e, 0x2d, 0x0f, 0x3d, 0xdd,
	0xb4, 0xf9, 0x2f, 0x0d, 0x0d, 0x51, 0xd7, 0xfa, 0x86, 0xf2, 0xe1, 0xff, 0xe8, 0x7f, 0xc7, 0xf4,
	0x21, 0x4a, 0x4e, 0xbf, 0x79, 0xfd, 0xbb, 0x57, 0x73, 0xc6, 0xf7, 0xaf, 0xe6, 0x8c, 0x1f, 0x5f,
	0xcd, 0x19, 0x2f, 0x7e, 0x9a, 0xfb, 0xcb, 0xbb, 0x8b, 0x99, 0x3f, 0xb0, 0x52, 0x4a, 0x4b, 0x01,
	0x0e, 0xb1, 0x47, 0x5c, 0x79, 0x18, 0x4f, 0x4f, 0x6b, 0x14, 0xd4, 0xfc, 0xfc, 0xef, 0xdf, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xbf, 0xd3, 0x12, 0x21, 0x2f, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DataServiceClient is the client API for DataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataServiceClient interface {
	// Fetch all deployments in the project identified by the given context ID.
	// Required permissions:
	// - data.deployment.list on the project identified by the given context ID
	ListDeployments(ctx context.Context, in *v1.ListOptions, opts ...grpc.CallOption) (*DeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Deployment, error)
	// Create a new deployment
	// Required permissions:
	// - data.deployment.create on the project that owns the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	CreateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error)
	// Update a deployment
	// Required permissions:
	// - data.deployment.update on the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	UpdateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error)
	// Delete a deployment
	// Note that deployments are initially only marked for deletion.
	// Once all their resources are removed the deployment itself is removed.
	// Required permissions:
	// - data.deployment.delete on the deployment
	DeleteDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Fetch all ArangoDB versions that are available for deployments.
	// Required permissions:
	// - None
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*VersionList, error)
	// Fetch the default ArangoDB version for new deployment.
	// Required permissions:
	// - None
	GetDefaultVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*Version, error)
	// Fetch the limits for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.limits.get on the requested project
	GetServersSpecLimits(ctx context.Context, in *ServersSpecLimitsRequest, opts ...grpc.CallOption) (*ServersSpecLimits, error)
	// Fetch the presets for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.presets.list on the requested project
	ListServersSpecPresets(ctx context.Context, in *ServersSpecPresetsRequest, opts ...grpc.CallOption) (*ServersSpecPresetList, error)
}

type dataServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataServiceClient(cc *grpc.ClientConn) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) ListDeployments(ctx context.Context, in *v1.ListOptions, opts ...grpc.CallOption) (*DeploymentList, error) {
	out := new(DeploymentList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListDeployments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) CreateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) UpdateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/UpdateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) DeleteDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/DeleteDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*VersionList, error) {
	out := new(VersionList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDefaultVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDefaultVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetServersSpecLimits(ctx context.Context, in *ServersSpecLimitsRequest, opts ...grpc.CallOption) (*ServersSpecLimits, error) {
	out := new(ServersSpecLimits)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetServersSpecLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListServersSpecPresets(ctx context.Context, in *ServersSpecPresetsRequest, opts ...grpc.CallOption) (*ServersSpecPresetList, error) {
	out := new(ServersSpecPresetList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListServersSpecPresets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServiceServer is the server API for DataService service.
type DataServiceServer interface {
	// Fetch all deployments in the project identified by the given context ID.
	// Required permissions:
	// - data.deployment.list on the project identified by the given context ID
	ListDeployments(context.Context, *v1.ListOptions) (*DeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeployment(context.Context, *v1.IDOptions) (*Deployment, error)
	// Create a new deployment
	// Required permissions:
	// - data.deployment.create on the project that owns the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	CreateDeployment(context.Context, *Deployment) (*Deployment, error)
	// Update a deployment
	// Required permissions:
	// - data.deployment.update on the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	UpdateDeployment(context.Context, *Deployment) (*Deployment, error)
	// Delete a deployment
	// Note that deployments are initially only marked for deletion.
	// Once all their resources are removed the deployment itself is removed.
	// Required permissions:
	// - data.deployment.delete on the deployment
	DeleteDeployment(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Fetch all ArangoDB versions that are available for deployments.
	// Required permissions:
	// - None
	ListVersions(context.Context, *ListVersionsRequest) (*VersionList, error)
	// Fetch the default ArangoDB version for new deployment.
	// Required permissions:
	// - None
	GetDefaultVersion(context.Context, *v1.Empty) (*Version, error)
	// Fetch the limits for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.limits.get on the requested project
	GetServersSpecLimits(context.Context, *ServersSpecLimitsRequest) (*ServersSpecLimits, error)
	// Fetch the presets for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.presets.list on the requested project
	ListServersSpecPresets(context.Context, *ServersSpecPresetsRequest) (*ServersSpecPresetList, error)
}

func RegisterDataServiceServer(s *grpc.Server, srv DataServiceServer) {
	s.RegisterService(&_DataService_serviceDesc, srv)
}

func _DataService_ListDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListDeployments(ctx, req.(*v1.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDeployment(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Deployment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CreateDeployment(ctx, req.(*Deployment))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_UpdateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Deployment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).UpdateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/UpdateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).UpdateDeployment(ctx, req.(*Deployment))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_DeleteDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).DeleteDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/DeleteDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).DeleteDeployment(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListVersions(ctx, req.(*ListVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDefaultVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDefaultVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDefaultVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDefaultVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetServersSpecLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServersSpecLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetServersSpecLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetServersSpecLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetServersSpecLimits(ctx, req.(*ServersSpecLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListServersSpecPresets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServersSpecPresetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListServersSpecPresets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListServersSpecPresets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListServersSpecPresets(ctx, req.(*ServersSpecPresetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.data.v1.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDeployments",
			Handler:    _DataService_ListDeployments_Handler,
		},
		{
			MethodName: "GetDeployment",
			Handler:    _DataService_GetDeployment_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _DataService_CreateDeployment_Handler,
		},
		{
			MethodName: "UpdateDeployment",
			Handler:    _DataService_UpdateDeployment_Handler,
		},
		{
			MethodName: "DeleteDeployment",
			Handler:    _DataService_DeleteDeployment_Handler,
		},
		{
			MethodName: "ListVersions",
			Handler:    _DataService_ListVersions_Handler,
		},
		{
			MethodName: "GetDefaultVersion",
			Handler:    _DataService_GetDefaultVersion_Handler,
		},
		{
			MethodName: "GetServersSpecLimits",
			Handler:    _DataService_GetServersSpecLimits_Handler,
		},
		{
			MethodName: "ListServersSpecPresets",
			Handler:    _DataService_ListServersSpecPresets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "data.proto",
}

func (m *Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.RegionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i += copy(dAtA[i:], m.RegionId)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DeletedAt != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DeletedAt.Size()))
		n2, err := m.DeletedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.IsDeleted {
		dAtA[i] = 0x48
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Certificates != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Certificates.Size()))
		n3, err := m.Certificates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Servers != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Servers.Size()))
		n4, err := m.Servers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Authentication != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Authentication.Size()))
		n5, err := m.Authentication.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Status != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Expiration != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Expiration.Size()))
		n7, err := m.Expiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_CertificateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_CertificateSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CaCertificateId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.CaCertificateId)))
		i += copy(dAtA[i:], m.CaCertificateId)
	}
	if len(m.AlternateDnsNames) > 0 {
		for _, s := range m.AlternateDnsNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_ServersSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_ServersSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coordinators != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize))
	}
	if len(m.CoordinatorArgs) > 0 {
		for _, s := range m.CoordinatorArgs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Dbservers != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize))
	}
	if len(m.DbserverArgs) > 0 {
		for _, s := range m.DbserverArgs {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_AuthenticationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_AuthenticationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RootPassword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.RootPassword)))
		i += copy(dAtA[i:], m.RootPassword)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_ServerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_ServerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(m.CreatedAt.Size()))
		n8, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Ready {
		dAtA[i] = 0x28
		i++
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MemberOfCluster {
		dAtA[i] = 0x30
		i++
		if m.MemberOfCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Failed {
		dAtA[i] = 0x38
		i++
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Created {
		dAtA[i] = 0x18
		i++
		if m.Created {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ready {
		dAtA[i] = 0x20
		i++
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Upgrading {
		dAtA[i] = 0x28
		i++
		if m.Upgrading {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ServerVersions) > 0 {
		for _, s := range m.ServerVersions {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Servers) > 0 {
		for _, msg := range m.Servers {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment_Expiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_Expiration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.ExpiresAt.Size()))
		n9, err := m.ExpiresAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.LastWarningEmailSendAt != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.LastWarningEmailSendAt.Size()))
		n10, err := m.LastWarningEmailSendAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for _, s := range m.LastWarningEmailSendTo {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecPresetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecPresetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.RegionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i += copy(dAtA[i:], m.RegionId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecPreset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecPreset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IsDefault {
		dAtA[i] = 0x10
		i++
		if m.IsDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Servers != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Servers.Size()))
		n11, err := m.Servers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecPresetList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecPresetList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeploymentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Budget != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Budget.Size()))
		n12, err := m.Budget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListVersionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVersionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Options.Size()))
		n13, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.OrganizationId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.OrganizationId)))
		i += copy(dAtA[i:], m.OrganizationId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecLimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.RegionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i += copy(dAtA[i:], m.RegionId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coordinators != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators.Size()))
		n14, err := m.Coordinators.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.CoordinatorMemorySize != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize.Size()))
		n15, err := m.CoordinatorMemorySize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Dbservers != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers.Size()))
		n16, err := m.Dbservers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DbserverMemorySize != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize.Size()))
		n17, err := m.DbserverMemorySize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.DbserverDiskSize != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize.Size()))
		n18, err := m.DbserverDiskSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServersSpecLimits_Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimits_Limits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Min != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Min))
	}
	if m.Max != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Max))
	}
	if len(m.AllowedValues) > 0 {
		dAtA20 := make([]byte, len(m.AllowedValues)*10)
		var j19 int
		for _, num1 := range m.AllowedValues {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.Certificates != nil {
		l = m.Certificates.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Servers != nil {
		l = m.Servers.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_CertificateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaCertificateId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.AlternateDnsNames) > 0 {
		for _, s := range m.AlternateDnsNames {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_ServersSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != 0 {
		n += 1 + sovData(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovData(uint64(m.CoordinatorMemorySize))
	}
	if len(m.CoordinatorArgs) > 0 {
		for _, s := range m.CoordinatorArgs {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.Dbservers != 0 {
		n += 1 + sovData(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovData(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovData(uint64(m.DbserverDiskSize))
	}
	if len(m.DbserverArgs) > 0 {
		for _, s := range m.DbserverArgs {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_AuthenticationSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootPassword)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_ServerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Ready {
		n += 2
	}
	if m.MemberOfCluster {
		n += 2
	}
	if m.Failed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Created {
		n += 2
	}
	if m.Ready {
		n += 2
	}
	if m.Upgrading {
		n += 2
	}
	if len(m.ServerVersions) > 0 {
		for _, s := range m.ServerVersions {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_Expiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiresAt != nil {
		l = m.ExpiresAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.LastWarningEmailSendAt != nil {
		l = m.LastWarningEmailSendAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for _, s := range m.LastWarningEmailSendTo {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecPresetsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecPreset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.IsDefault {
		n += 2
	}
	if m.Servers != nil {
		l = m.Servers.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecPresetList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.Budget != nil {
		l = m.Budget.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListVersionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != nil {
		l = m.Coordinators.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.CoordinatorMemorySize != nil {
		l = m.CoordinatorMemorySize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Dbservers != nil {
		l = m.Dbservers.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DbserverMemorySize != nil {
		l = m.DbserverMemorySize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DbserverDiskSize != nil {
		l = m.DbserverDiskSize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimits_Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Min != 0 {
		n += 1 + sovData(uint64(m.Min))
	}
	if m.Max != 0 {
		n += 1 + sovData(uint64(m.Max))
	}
	if len(m.AllowedValues) > 0 {
		l = 0
		for _, e := range m.AllowedValues {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Certificates == nil {
				m.Certificates = &Deployment_CertificateSpec{}
			}
			if err := m.Certificates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Servers == nil {
				m.Servers = &Deployment_ServersSpec{}
			}
			if err := m.Servers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authentication == nil {
				m.Authentication = &Deployment_AuthenticationSpec{}
			}
			if err := m.Authentication.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Deployment_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &Deployment_Expiration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_CertificateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateDnsNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateDnsNames = append(m.AlternateDnsNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_ServersSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoordinatorArgs = append(m.CoordinatorArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbserverArgs = append(m.DbserverArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_AuthenticationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_ServerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberOfCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemberOfCluster = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Created = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upgrading", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upgrading = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersions = append(m.ServerVersions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &Deployment_ServerStatus{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_Expiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = &types.Timestamp{}
			}
			if err := m.ExpiresAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastWarningEmailSendAt == nil {
				m.LastWarningEmailSendAt = &types.Timestamp{}
			}
			if err := m.LastWarningEmailSendAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastWarningEmailSendTo = append(m.LastWarningEmailSendTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecPresetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecPresetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecPresetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecPreset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecPreset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecPreset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefault = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Servers == nil {
				m.Servers = &Deployment_ServersSpec{}
			}
			if err := m.Servers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecPresetList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecPresetList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecPresetList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ServersSpecPreset{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Deployment{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Budget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Budget == nil {
				m.Budget = &v1.Budget{}
			}
			if err := m.Budget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Version{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVersionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVersionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVersionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecLimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecLimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinators == nil {
				m.Coordinators = &ServersSpecLimits_Limits{}
			}
			if err := m.Coordinators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoordinatorMemorySize == nil {
				m.CoordinatorMemorySize = &ServersSpecLimits_Limits{}
			}
			if err := m.CoordinatorMemorySize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbservers == nil {
				m.Dbservers = &ServersSpecLimits_Limits{}
			}
			if err := m.Dbservers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbserverMemorySize == nil {
				m.DbserverMemorySize = &ServersSpecLimits_Limits{}
			}
			if err := m.DbserverMemorySize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbserverDiskSize == nil {
				m.DbserverDiskSize = &ServersSpecLimits_Limits{}
			}
			if err := m.DbserverDiskSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimits_Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowedValues = append(m.AllowedValues, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllowedValues) == 0 {
					m.AllowedValues = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowedValues = append(m.AllowedValues, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedValues", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthData
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)
