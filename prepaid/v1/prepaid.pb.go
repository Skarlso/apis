// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: prepaid.proto

package v1

import (
	context "context"
	fmt "fmt"
	v11 "github.com/arangodb-managed/apis/common/v1"
	v1 "github.com/arangodb-managed/apis/data/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A PrepaidDeployment is represents one deployment of an ArangoDB cluster.
type PrepaidDeployment struct {
	// System identifier of the deployment.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Identifier of the region in which the deployment is created.
	// After creation, this value cannot be changed.
	RegionId string `protobuf:"bytes,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The creation timestamp of the deployment
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the deployment
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,8,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this deployment is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,9,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Optional identifier of the support plan selected for this deployment.
	// After creation, this value cannot be changed.
	// If no support plan identifier is set, the default support plan is used.
	SupportPlanId string `protobuf:"bytes,10,opt,name=support_plan_id,json=supportPlanId,proto3" json:"support_plan_id,omitempty"`
	// Identifier of the user who created this deployment.
	// This is a read-only value.
	CreatedById string `protobuf:"bytes,11,opt,name=created_by_id,json=createdById,proto3" json:"created_by_id,omitempty"`
	// If set, this deployment cannot be deleted.
	// To delete, first update the with locked set to false.
	Locked bool `protobuf:"varint,13,opt,name=locked,proto3" json:"locked,omitempty"`
	// If set, this deployment will be upgraded to the ArangoDB release with the
	// version as listed in this field.
	ReplaceVersionBy *v1.ReplaceVersionBy `protobuf:"bytes,104,opt,name=replace_version_by,json=replaceVersionBy,proto3" json:"replace_version_by,omitempty"`
	// If set, it is recommended to upgrade to the ArangoDB release with the
	// version as listed in this field.
	UpgradeRecommendation *v1.UpgradeVersionRecommendation `protobuf:"bytes,105,opt,name=upgrade_recommendation,json=upgradeRecommendation,proto3" json:"upgrade_recommendation,omitempty"`
	Servers               *PrepaidDeployment_ServersSpec   `protobuf:"bytes,103,opt,name=servers,proto3" json:"servers,omitempty"`
	// Optional identifier of IP allowlist to use for this deployment.
	IpallowlistId string                       `protobuf:"bytes,109,opt,name=ipallowlist_id,json=ipallowlistId,proto3" json:"ipallowlist_id,omitempty"`
	Model         *PrepaidDeployment_ModelSpec `protobuf:"bytes,106,opt,name=model,proto3" json:"model,omitempty"`
	// If provided, dataclusterd will use this custom image tag instead of the configured one for a given version.
	// Further, ImagePullPolicy will be set to Always.
	// This field can only be set by selected organizations.
	CustomImage string `protobuf:"bytes,107,opt,name=custom_image,json=customImage,proto3" json:"custom_image,omitempty"`
	// Optional identifier of IAM provider to use for this deployment.
	IamproviderId string                        `protobuf:"bytes,108,opt,name=iamprovider_id,json=iamproviderId,proto3" json:"iamprovider_id,omitempty"`
	Status        *PrepaidDeployment_Status     `protobuf:"bytes,201,opt,name=status,proto3" json:"status,omitempty"`
	Expiration    *PrepaidDeployment_Expiration `protobuf:"bytes,301,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// Information about a backup restore.
	// If this field is set the deployment will be restored to that backup.
	// This is a read-only field. To set this field please use the backup service RestoreBackup method.
	BackupRestore        *PrepaidDeployment_BackupRestoreSpec `protobuf:"bytes,401,opt,name=backup_restore,json=backupRestore,proto3" json:"backup_restore,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *PrepaidDeployment) Reset()         { *m = PrepaidDeployment{} }
func (m *PrepaidDeployment) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment) ProtoMessage()    {}
func (*PrepaidDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0}
}
func (m *PrepaidDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment.Merge(m, src)
}
func (m *PrepaidDeployment) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment proto.InternalMessageInfo

func (m *PrepaidDeployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PrepaidDeployment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PrepaidDeployment) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *PrepaidDeployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PrepaidDeployment) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *PrepaidDeployment) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *PrepaidDeployment) GetSupportPlanId() string {
	if m != nil {
		return m.SupportPlanId
	}
	return ""
}

func (m *PrepaidDeployment) GetCreatedById() string {
	if m != nil {
		return m.CreatedById
	}
	return ""
}

func (m *PrepaidDeployment) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

func (m *PrepaidDeployment) GetReplaceVersionBy() *v1.ReplaceVersionBy {
	if m != nil {
		return m.ReplaceVersionBy
	}
	return nil
}

func (m *PrepaidDeployment) GetUpgradeRecommendation() *v1.UpgradeVersionRecommendation {
	if m != nil {
		return m.UpgradeRecommendation
	}
	return nil
}

func (m *PrepaidDeployment) GetServers() *PrepaidDeployment_ServersSpec {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *PrepaidDeployment) GetIpallowlistId() string {
	if m != nil {
		return m.IpallowlistId
	}
	return ""
}

func (m *PrepaidDeployment) GetModel() *PrepaidDeployment_ModelSpec {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *PrepaidDeployment) GetCustomImage() string {
	if m != nil {
		return m.CustomImage
	}
	return ""
}

func (m *PrepaidDeployment) GetIamproviderId() string {
	if m != nil {
		return m.IamproviderId
	}
	return ""
}

func (m *PrepaidDeployment) GetStatus() *PrepaidDeployment_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PrepaidDeployment) GetExpiration() *PrepaidDeployment_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *PrepaidDeployment) GetBackupRestore() *PrepaidDeployment_BackupRestoreSpec {
	if m != nil {
		return m.BackupRestore
	}
	return nil
}

type PrepaidDeployment_ServersSpec struct {
	// Number of coordinators of the deployment
	// This field is automatically set unless the flexible model is used.
	Coordinators int32 `protobuf:"varint,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for coordinators.
	// This field is automatically set unless the flexible model is used.
	CoordinatorMemorySize int32 `protobuf:"varint,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Custom command line arguments passed to all coordinators.
	// This field is ignored set unless the flexible model is used.
	CoordinatorArgs []string `protobuf:"bytes,3,rep,name=coordinator_args,json=coordinatorArgs,proto3" json:"coordinator_args,omitempty"`
	// Number of dbservers of the deployment
	// This field is automatically set unless the flexible model is used.
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for dbservers.
	// This field is automatically set unless the flexible model is used.
	DbserverMemorySize int32 `protobuf:"varint,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for dbservers.
	// This field is automatically set unless the flexible model is used.
	DbserverDiskSize int32 `protobuf:"varint,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Custom command line arguments passed to all dbservers.
	// This field is ignored set unless the flexible model is used.
	DbserverArgs []string `protobuf:"bytes,14,rep,name=dbserver_args,json=dbserverArgs,proto3" json:"dbserver_args,omitempty"`
	// The minimum number of dbservers based on the highest replication factor
	// defined by all databases and all collections.
	MinimumDbserversCount int32    `protobuf:"varint,15,opt,name=minimum_dbservers_count,json=minimumDbserversCount,proto3" json:"minimum_dbservers_count,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *PrepaidDeployment_ServersSpec) Reset()         { *m = PrepaidDeployment_ServersSpec{} }
func (m *PrepaidDeployment_ServersSpec) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_ServersSpec) ProtoMessage()    {}
func (*PrepaidDeployment_ServersSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 0}
}
func (m *PrepaidDeployment_ServersSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_ServersSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_ServersSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_ServersSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_ServersSpec.Merge(m, src)
}
func (m *PrepaidDeployment_ServersSpec) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_ServersSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_ServersSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_ServersSpec proto.InternalMessageInfo

func (m *PrepaidDeployment_ServersSpec) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *PrepaidDeployment_ServersSpec) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *PrepaidDeployment_ServersSpec) GetCoordinatorArgs() []string {
	if m != nil {
		return m.CoordinatorArgs
	}
	return nil
}

func (m *PrepaidDeployment_ServersSpec) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *PrepaidDeployment_ServersSpec) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *PrepaidDeployment_ServersSpec) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

func (m *PrepaidDeployment_ServersSpec) GetDbserverArgs() []string {
	if m != nil {
		return m.DbserverArgs
	}
	return nil
}

func (m *PrepaidDeployment_ServersSpec) GetMinimumDbserversCount() int32 {
	if m != nil {
		return m.MinimumDbserversCount
	}
	return 0
}

type PrepaidDeployment_ModelSpec struct {
	// Type of model being used
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Size of nodes being used
	// This field is ignored set in case the flexible model is used.
	NodeSizeId string `protobuf:"bytes,2,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Number of nodes being used
	// This field is ignored set in case the flexible model is used.
	NodeCount int32 `protobuf:"varint,3,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Amount of disk space per node (in GB)
	// This field is ignored set in case the flexible model is used.
	NodeDiskSize         int32    `protobuf:"varint,4,opt,name=node_disk_size,json=nodeDiskSize,proto3" json:"node_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrepaidDeployment_ModelSpec) Reset()         { *m = PrepaidDeployment_ModelSpec{} }
func (m *PrepaidDeployment_ModelSpec) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_ModelSpec) ProtoMessage()    {}
func (*PrepaidDeployment_ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 1}
}
func (m *PrepaidDeployment_ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_ModelSpec.Merge(m, src)
}
func (m *PrepaidDeployment_ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_ModelSpec proto.InternalMessageInfo

func (m *PrepaidDeployment_ModelSpec) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *PrepaidDeployment_ModelSpec) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *PrepaidDeployment_ModelSpec) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *PrepaidDeployment_ModelSpec) GetNodeDiskSize() int32 {
	if m != nil {
		return m.NodeDiskSize
	}
	return 0
}

// Status of the prepaid deployment
// All members of this field are read-only.
type PrepaidDeployment_Status struct {
	Deployment           *v1.Deployment `protobuf:"bytes,1,opt,name=deployment,proto3" json:"deployment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PrepaidDeployment_Status) Reset()         { *m = PrepaidDeployment_Status{} }
func (m *PrepaidDeployment_Status) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_Status) ProtoMessage()    {}
func (*PrepaidDeployment_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 2}
}
func (m *PrepaidDeployment_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_Status.Merge(m, src)
}
func (m *PrepaidDeployment_Status) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_Status.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_Status proto.InternalMessageInfo

func (m *PrepaidDeployment_Status) GetDeployment() *v1.Deployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

// Expiration of the deployment.
// All members of this message are read-only.
type PrepaidDeployment_Expiration struct {
	// The expiration timestamp of the deployment
	// If not set, the deployment will not expire.
	ExpiresAt *types.Timestamp `protobuf:"bytes,1,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Human readable reason for why the deployment expires (or does not expire).
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// The timestamp of when the last "this deployment will expire at" email was
	// send.
	// If not set, no such email has been send.
	LastWarningEmailSendAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_warning_email_send_at,json=lastWarningEmailSendAt,proto3" json:"last_warning_email_send_at,omitempty"`
	// List of email addresses to which the last warning email has been send.
	// Not set when no such email has been send.
	LastWarningEmailSendTo []string `protobuf:"bytes,4,rep,name=last_warning_email_send_to,json=lastWarningEmailSendTo,proto3" json:"last_warning_email_send_to,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *PrepaidDeployment_Expiration) Reset()         { *m = PrepaidDeployment_Expiration{} }
func (m *PrepaidDeployment_Expiration) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_Expiration) ProtoMessage()    {}
func (*PrepaidDeployment_Expiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 3}
}
func (m *PrepaidDeployment_Expiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_Expiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_Expiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_Expiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_Expiration.Merge(m, src)
}
func (m *PrepaidDeployment_Expiration) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_Expiration) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_Expiration.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_Expiration proto.InternalMessageInfo

func (m *PrepaidDeployment_Expiration) GetExpiresAt() *types.Timestamp {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *PrepaidDeployment_Expiration) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PrepaidDeployment_Expiration) GetLastWarningEmailSendAt() *types.Timestamp {
	if m != nil {
		return m.LastWarningEmailSendAt
	}
	return nil
}

func (m *PrepaidDeployment_Expiration) GetLastWarningEmailSendTo() []string {
	if m != nil {
		return m.LastWarningEmailSendTo
	}
	return nil
}

// Information about a backup restore.
// All members of this message are read-only.
type PrepaidDeployment_BackupRestoreSpec struct {
	// The revision of this BackupRestoreSpec
	Revision int32 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// The timestamp of when the last revision has been updated.
	LastUpdatedAt *types.Timestamp `protobuf:"bytes,2,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Identifier of a backup to restore to.
	BackupId             string   `protobuf:"bytes,10,opt,name=backup_id,json=backupId,proto3" json:"backup_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrepaidDeployment_BackupRestoreSpec) Reset()         { *m = PrepaidDeployment_BackupRestoreSpec{} }
func (m *PrepaidDeployment_BackupRestoreSpec) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_BackupRestoreSpec) ProtoMessage()    {}
func (*PrepaidDeployment_BackupRestoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 4}
}
func (m *PrepaidDeployment_BackupRestoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_BackupRestoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_BackupRestoreSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_BackupRestoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_BackupRestoreSpec.Merge(m, src)
}
func (m *PrepaidDeployment_BackupRestoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_BackupRestoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_BackupRestoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_BackupRestoreSpec proto.InternalMessageInfo

func (m *PrepaidDeployment_BackupRestoreSpec) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *PrepaidDeployment_BackupRestoreSpec) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

func (m *PrepaidDeployment_BackupRestoreSpec) GetBackupId() string {
	if m != nil {
		return m.BackupId
	}
	return ""
}

type PrepaidDeploymentList struct {
	Items                []*PrepaidDeployment `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PrepaidDeploymentList) Reset()         { *m = PrepaidDeploymentList{} }
func (m *PrepaidDeploymentList) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeploymentList) ProtoMessage()    {}
func (*PrepaidDeploymentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{1}
}
func (m *PrepaidDeploymentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeploymentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeploymentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeploymentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeploymentList.Merge(m, src)
}
func (m *PrepaidDeploymentList) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeploymentList) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeploymentList.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeploymentList proto.InternalMessageInfo

func (m *PrepaidDeploymentList) GetItems() []*PrepaidDeployment {
	if m != nil {
		return m.Items
	}
	return nil
}

type CreateDeploymentRequest struct {
	Id        string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Optional identifier of IP allowlist to use for this deployment.
	IpallowlistId string `protobuf:"bytes,3,opt,name=ipallowlist_id,json=ipallowlistId,proto3" json:"ipallowlist_id,omitempty"`
	// ArangoDB version to use for this deployment.
	// See Version.version.
	// If you change this value to a higher version,
	// the deployment will be upgraded.
	// If you change this value to a lower patch value,
	// the deployment will be downgraded.
	// Any attempt to change to a lower minor or major version
	// is considered an invalid request.
	// Any attempt to change to a version that is not in the
	// list of available versions is considered an invalid request.
	Version              string                                   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Certificates         *CreateDeploymentRequest_CertificateSpec `protobuf:"bytes,5,opt,name=certificates,proto3" json:"certificates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *CreateDeploymentRequest) Reset()         { *m = CreateDeploymentRequest{} }
func (m *CreateDeploymentRequest) String() string { return proto.CompactTextString(m) }
func (*CreateDeploymentRequest) ProtoMessage()    {}
func (*CreateDeploymentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{2}
}
func (m *CreateDeploymentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDeploymentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDeploymentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDeploymentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDeploymentRequest.Merge(m, src)
}
func (m *CreateDeploymentRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateDeploymentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDeploymentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDeploymentRequest proto.InternalMessageInfo

func (m *CreateDeploymentRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateDeploymentRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *CreateDeploymentRequest) GetIpallowlistId() string {
	if m != nil {
		return m.IpallowlistId
	}
	return ""
}

func (m *CreateDeploymentRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CreateDeploymentRequest) GetCertificates() *CreateDeploymentRequest_CertificateSpec {
	if m != nil {
		return m.Certificates
	}
	return nil
}

type CreateDeploymentRequest_CertificateSpec struct {
	// Identifier of the CACertificate used to sign TLS certificates for the deployment.
	// If you change this value after the creation of the deployment a complete
	// rotation of the deployment is required, which will result in some downtime.
	CaCertificateId string `protobuf:"bytes,1,opt,name=ca_certificate_id,json=caCertificateId,proto3" json:"ca_certificate_id,omitempty"`
	// Zero or more DNS names to include in the TLS certificate of the deployment.
	AlternateDnsNames    []string `protobuf:"bytes,2,rep,name=alternate_dns_names,json=alternateDnsNames,proto3" json:"alternate_dns_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDeploymentRequest_CertificateSpec) Reset() {
	*m = CreateDeploymentRequest_CertificateSpec{}
}
func (m *CreateDeploymentRequest_CertificateSpec) String() string { return proto.CompactTextString(m) }
func (*CreateDeploymentRequest_CertificateSpec) ProtoMessage()    {}
func (*CreateDeploymentRequest_CertificateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{2, 0}
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.Merge(m, src)
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Size() int {
	return m.Size()
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDeploymentRequest_CertificateSpec proto.InternalMessageInfo

func (m *CreateDeploymentRequest_CertificateSpec) GetCaCertificateId() string {
	if m != nil {
		return m.CaCertificateId
	}
	return ""
}

func (m *CreateDeploymentRequest_CertificateSpec) GetAlternateDnsNames() []string {
	if m != nil {
		return m.AlternateDnsNames
	}
	return nil
}

func init() {
	proto.RegisterType((*PrepaidDeployment)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment")
	proto.RegisterType((*PrepaidDeployment_ServersSpec)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.ServersSpec")
	proto.RegisterType((*PrepaidDeployment_ModelSpec)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.ModelSpec")
	proto.RegisterType((*PrepaidDeployment_Status)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.Status")
	proto.RegisterType((*PrepaidDeployment_Expiration)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.Expiration")
	proto.RegisterType((*PrepaidDeployment_BackupRestoreSpec)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.BackupRestoreSpec")
	proto.RegisterType((*PrepaidDeploymentList)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeploymentList")
	proto.RegisterType((*CreateDeploymentRequest)(nil), "arangodb.cloud.prepaid.v1.CreateDeploymentRequest")
	proto.RegisterType((*CreateDeploymentRequest_CertificateSpec)(nil), "arangodb.cloud.prepaid.v1.CreateDeploymentRequest.CertificateSpec")
}

func init() { proto.RegisterFile("prepaid.proto", fileDescriptor_862bc918d3ba4c11) }

var fileDescriptor_862bc918d3ba4c11 = []byte{
	// 1396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x5f, 0x6f, 0x1b, 0xc5,
	0x16, 0xbf, 0x6b, 0x37, 0x7f, 0x7c, 0x12, 0xe7, 0xcf, 0xdc, 0x36, 0xdd, 0xba, 0x6d, 0x6e, 0xea,
	0xde, 0xf6, 0xe6, 0xf6, 0x8f, 0xdd, 0xa4, 0xa8, 0x40, 0x11, 0x48, 0x71, 0x52, 0x2a, 0x4b, 0x2d,
	0x54, 0x9b, 0xb6, 0x20, 0x78, 0x58, 0x8d, 0x77, 0x26, 0xdb, 0x69, 0x76, 0x77, 0x96, 0x99, 0xb1,
	0x5b, 0x17, 0xf1, 0xc2, 0x03, 0xf0, 0x06, 0xa8, 0x12, 0xf0, 0xc4, 0x37, 0xe0, 0x7b, 0xc0, 0x1b,
	0x12, 0x5f, 0xa0, 0x2a, 0xbc, 0xf3, 0xc0, 0x17, 0x40, 0x33, 0xb3, 0x6b, 0x6f, 0x92, 0xba, 0xc1,
	0x52, 0x9f, 0xe2, 0xf9, 0x9d, 0xf3, 0x3b, 0xe7, 0x37, 0x67, 0xce, 0x9e, 0x99, 0x40, 0x35, 0x15,
	0x34, 0xc5, 0x8c, 0x34, 0x52, 0xc1, 0x15, 0x47, 0x27, 0xb0, 0xc0, 0x49, 0xc8, 0x49, 0xa7, 0x11,
	0x44, 0xbc, 0xab, 0x51, 0x6b, 0xed, 0xad, 0xd5, 0x96, 0x02, 0x1e, 0xc7, 0x3c, 0x69, 0xf6, 0xd6,
	0x9a, 0xf6, 0x97, 0xa5, 0xd4, 0x10, 0xc1, 0x0a, 0x6b, 0x54, 0xff, 0xcd, 0xb0, 0xb7, 0x42, 0xa6,
	0x1e, 0x74, 0x3b, 0x8d, 0x80, 0xc7, 0xcd, 0x90, 0x47, 0x38, 0x09, 0x9b, 0xc6, 0xd0, 0xe9, 0xee,
	0x34, 0x53, 0xd5, 0x4f, 0xa9, 0x6c, 0x2a, 0x16, 0x53, 0xa9, 0x70, 0x9c, 0x0e, 0x7f, 0x65, 0xe4,
	0x53, 0x21, 0xe7, 0x61, 0x44, 0x9b, 0x38, 0x65, 0x4d, 0x9c, 0x24, 0x5c, 0x61, 0xc5, 0x78, 0x22,
	0xad, 0xb5, 0xfe, 0xe5, 0x02, 0x2c, 0xde, 0xb1, 0xaa, 0xb6, 0x68, 0x1a, 0xf1, 0x7e, 0x4c, 0x13,
	0x85, 0xe6, 0xa0, 0xc4, 0x88, 0xeb, 0xac, 0x38, 0xab, 0x15, 0xaf, 0xc4, 0x08, 0x5a, 0x80, 0x72,
	0x57, 0x44, 0x6e, 0xc9, 0x00, 0xfa, 0x27, 0x3a, 0x09, 0x15, 0x41, 0x43, 0xc6, 0x13, 0x9f, 0x11,
	0x77, 0xd2, 0xe0, 0xd3, 0x16, 0x68, 0x13, 0xf4, 0x26, 0x40, 0x20, 0x28, 0x56, 0x94, 0xf8, 0x58,
	0xb9, 0x53, 0x2b, 0xce, 0xea, 0xcc, 0x7a, 0xad, 0x61, 0x75, 0x34, 0x72, 0xe5, 0x8d, 0xbb, 0xb9,
	0x50, 0xaf, 0x92, 0x79, 0x6f, 0x28, 0x4d, 0x25, 0x34, 0xa2, 0x19, 0x75, 0xfa, 0x70, 0x6a, 0xe6,
	0xbd, 0xa1, 0xd0, 0x69, 0x00, 0x26, 0xfd, 0x6c, 0xed, 0x56, 0x56, 0x9c, 0xd5, 0x69, 0xaf, 0xc2,
	0xe4, 0x96, 0x05, 0xd0, 0x79, 0x98, 0x97, 0xdd, 0x34, 0xe5, 0x42, 0xf9, 0x69, 0x84, 0x8d, 0x6e,
	0x30, 0xba, 0xab, 0x19, 0x7c, 0x27, 0xc2, 0x5a, 0x7c, 0x1d, 0xaa, 0xb9, 0xf8, 0x4e, 0x5f, 0x7b,
	0xcd, 0x18, 0xaf, 0x99, 0x0c, 0x6c, 0xf5, 0xdb, 0x04, 0x2d, 0xc1, 0x64, 0xc4, 0x83, 0x5d, 0x4a,
	0xdc, 0xaa, 0x49, 0x93, 0xad, 0xd0, 0x7d, 0x40, 0x82, 0xa6, 0x11, 0x0e, 0xa8, 0xdf, 0xa3, 0x42,
	0xea, 0xf2, 0x74, 0xfa, 0xee, 0x03, 0xb3, 0x8b, 0xd5, 0xc6, 0xbe, 0x66, 0x30, 0x07, 0xdc, 0x5b,
	0x6b, 0x78, 0x96, 0x71, 0xdf, 0x12, 0x5a, 0x7d, 0x6f, 0x41, 0xec, 0x43, 0xd0, 0x2e, 0x2c, 0x75,
	0xd3, 0x50, 0x60, 0x42, 0x7d, 0x41, 0x75, 0xbb, 0xd0, 0x84, 0x98, 0x63, 0x74, 0x99, 0x89, 0xfd,
	0xda, 0xa8, 0xd8, 0xf7, 0x2c, 0x2b, 0x8b, 0xe4, 0xed, 0xe1, 0x7a, 0xc7, 0xb2, 0x98, 0x7b, 0x61,
	0xe4, 0xc1, 0x94, 0xa4, 0x42, 0xeb, 0x77, 0x43, 0x13, 0xfd, 0x8d, 0xc6, 0xc8, 0x36, 0x6e, 0x1c,
	0xe8, 0x9d, 0xc6, 0xb6, 0xe5, 0x6e, 0xa7, 0x34, 0xf0, 0xf2, 0x40, 0xe8, 0x1c, 0xcc, 0xb1, 0x14,
	0x47, 0x11, 0x7f, 0x14, 0x31, 0xa9, 0x74, 0x55, 0x63, 0x5b, 0xfb, 0x02, 0xda, 0x26, 0xe8, 0x16,
	0x4c, 0xc4, 0x9c, 0xd0, 0xc8, 0x7d, 0x68, 0x12, 0x5f, 0x1b, 0x2b, 0xf1, 0x6d, 0xcd, 0x34, 0x69,
	0x6d, 0x10, 0x74, 0x06, 0x66, 0x83, 0xae, 0x54, 0x3c, 0xf6, 0x59, 0x8c, 0x43, 0xea, 0xee, 0x66,
	0x07, 0x69, 0xb0, 0xb6, 0x86, 0x8c, 0x2e, 0x1c, 0xa7, 0x82, 0xf7, 0x18, 0xa1, 0x42, 0xeb, 0x8a,
	0x32, 0x5d, 0x43, 0xd4, 0xe8, 0x9a, 0x94, 0x0a, 0xab, 0xae, 0x74, 0x7f, 0x71, 0x8c, 0xb2, 0xab,
	0xe3, 0x95, 0xc4, 0x70, 0xbd, 0x2c, 0x06, 0xfa, 0x10, 0x80, 0x3e, 0x4e, 0x99, 0xb0, 0x27, 0xf8,
	0x53, 0xc9, 0x44, 0x7c, 0x7d, 0xac, 0x88, 0x37, 0x06, 0x7c, 0xaf, 0x10, 0x0b, 0xed, 0xc0, 0x5c,
	0x07, 0x07, 0xbb, 0xdd, 0xd4, 0x17, 0x54, 0x2a, 0x2e, 0xa8, 0xfb, 0x6d, 0xd9, 0x44, 0x7f, 0x67,
	0xac, 0xe8, 0x2d, 0x13, 0xc3, 0xb3, 0x21, 0x4c, 0x45, 0xab, 0x9d, 0x22, 0x54, 0xfb, 0xb3, 0x04,
	0x33, 0x85, 0x73, 0x46, 0x75, 0x98, 0x0d, 0x38, 0x17, 0x84, 0x25, 0x58, 0x71, 0x21, 0xcd, 0xe4,
	0x98, 0xf0, 0xf6, 0x60, 0xe8, 0x1a, 0x1c, 0x2f, 0xac, 0xfd, 0x98, 0xc6, 0x5c, 0xf4, 0x7d, 0xc9,
	0x9e, 0x50, 0x33, 0x57, 0x26, 0xbc, 0x63, 0x05, 0xf3, 0x6d, 0x63, 0xdd, 0x66, 0x4f, 0x28, 0xfa,
	0x3f, 0x2c, 0x14, 0x79, 0x58, 0x84, 0xd2, 0x2d, 0xaf, 0x94, 0x57, 0x2b, 0xde, 0x7c, 0x01, 0xdf,
	0x10, 0xa1, 0x44, 0xa7, 0xa0, 0x42, 0x3a, 0x79, 0xef, 0xce, 0x98, 0xa0, 0x43, 0x00, 0x5d, 0x81,
	0xa3, 0xf9, 0x62, 0x4f, 0xf6, 0x59, 0xe3, 0x88, 0x72, 0x5b, 0x21, 0xf5, 0x25, 0x18, 0xa0, 0x3e,
	0x61, 0x72, 0xd7, 0xfa, 0x57, 0x8d, 0xff, 0x42, 0x6e, 0xd9, 0x62, 0x72, 0xd7, 0x78, 0x9f, 0x85,
	0xea, 0xc0, 0xdb, 0xa8, 0x9c, 0x33, 0x2a, 0x67, 0x73, 0xd0, 0x48, 0xbc, 0x06, 0xc7, 0x63, 0x96,
	0xb0, 0xb8, 0x1b, 0xfb, 0x03, 0x65, 0x7e, 0xc0, 0xbb, 0x89, 0x72, 0xe7, 0x6d, 0x15, 0x32, 0xf3,
	0x56, 0x6e, 0xdd, 0xd4, 0xc6, 0xda, 0x57, 0x0e, 0x54, 0x06, 0x0d, 0x8e, 0x8e, 0xe6, 0xdf, 0x89,
	0x1d, 0xd1, 0x59, 0xbf, 0xaf, 0xc0, 0x6c, 0xc2, 0x09, 0x35, 0x2a, 0x75, 0x2b, 0xdb, 0x71, 0x0d,
	0x1a, 0xd3, 0x02, 0xdb, 0x44, 0x8f, 0x48, 0xe3, 0x61, 0x13, 0x96, 0x6d, 0x85, 0x34, 0x62, 0x92,
	0xa0, 0xff, 0xc2, 0x9c, 0x31, 0x0f, 0xf7, 0x7a, 0xc4, 0x1e, 0xa4, 0x46, 0xf3, 0x7d, 0xd6, 0x6e,
	0xc1, 0xa4, 0x6d, 0x68, 0xd4, 0xd2, 0xc3, 0x3a, 0xef, 0x1a, 0xd7, 0x7e, 0x19, 0xf5, 0x51, 0xa3,
	0x68, 0xd8, 0x5f, 0x5e, 0x81, 0x55, 0xfb, 0xcb, 0x01, 0x18, 0x76, 0xb3, 0x9e, 0xff, 0xa6, 0x9f,
	0xa9, 0xd4, 0xf3, 0xdf, 0x39, 0x7c, 0xfe, 0x67, 0xde, 0x1b, 0x4a, 0x0f, 0x65, 0x41, 0xb1, 0xe4,
	0x49, 0xb6, 0xf1, 0x6c, 0x85, 0xee, 0x43, 0x2d, 0xc2, 0x52, 0xf9, 0x8f, 0xb0, 0x48, 0x58, 0x12,
	0xfa, 0x34, 0xc6, 0x2c, 0xf2, 0x25, 0x4d, 0xcc, 0x15, 0x53, 0x3e, 0x34, 0xc5, 0x92, 0x66, 0x7f,
	0x60, 0xc9, 0x37, 0x34, 0x77, 0x9b, 0x26, 0xfa, 0xbe, 0xb9, 0x3e, 0x3a, 0xae, 0xe2, 0xee, 0x11,
	0x73, 0xf8, 0x2f, 0xe4, 0xde, 0xe5, 0xb5, 0x6f, 0x1c, 0x58, 0x3c, 0xf0, 0x95, 0xa1, 0x1a, 0x4c,
	0x0b, 0xda, 0x63, 0x7a, 0x54, 0x67, 0x9f, 0xd0, 0x60, 0x8d, 0x5a, 0x30, 0x6f, 0xb2, 0x75, 0x53,
	0x92, 0x5f, 0xac, 0xa5, 0x43, 0xa5, 0x57, 0x35, 0xe5, 0x9e, 0x65, 0x6c, 0x28, 0x7d, 0x69, 0x67,
	0xe3, 0x61, 0x70, 0xf9, 0x4d, 0x5b, 0xa0, 0x4d, 0xea, 0x1f, 0xc3, 0xb1, 0x03, 0x93, 0xe0, 0x16,
	0x93, 0x0a, 0xb5, 0x60, 0x82, 0x29, 0x1a, 0xeb, 0xaf, 0xba, 0xbc, 0x3a, 0xb3, 0x7e, 0x69, 0x9c,
	0x51, 0xe2, 0x59, 0x6a, 0xfd, 0x59, 0x09, 0x8e, 0x6f, 0x9a, 0x0b, 0xb4, 0x60, 0xa3, 0x9f, 0x74,
	0xa9, 0x3c, 0xf8, 0xd8, 0x38, 0x0d, 0x90, 0x0a, 0xfe, 0x90, 0x06, 0x6a, 0xd8, 0xc4, 0x95, 0x0c,
	0x69, 0x93, 0x17, 0x5c, 0x25, 0xe5, 0x17, 0x5d, 0x25, 0x2e, 0x4c, 0x65, 0x57, 0xb0, 0x69, 0xe2,
	0x8a, 0x97, 0x2f, 0xd1, 0x0e, 0xcc, 0x06, 0x54, 0x28, 0xb6, 0xc3, 0x02, 0xac, 0xa8, 0x74, 0x27,
	0x4c, 0x19, 0x5b, 0x2f, 0xd9, 0xd6, 0x08, 0xe5, 0x8d, 0xcd, 0x61, 0x18, 0x33, 0x25, 0xf7, 0xc4,
	0xad, 0xc5, 0x30, 0xbf, 0xcf, 0x01, 0x5d, 0x80, 0xc5, 0x00, 0xfb, 0x05, 0x2f, 0x7f, 0xb0, 0xf3,
	0xf9, 0x00, 0x17, 0xbc, 0xdb, 0x04, 0x35, 0xe0, 0xdf, 0x38, 0x52, 0x54, 0x24, 0xda, 0x8d, 0x24,
	0xd2, 0x4f, 0x70, 0x4c, 0xa5, 0x5b, 0x32, 0x7d, 0xb5, 0x38, 0x30, 0x6d, 0x25, 0xf2, 0x3d, 0x6d,
	0x58, 0xff, 0x62, 0x0a, 0xe6, 0xb2, 0xfa, 0xeb, 0xd1, 0xcc, 0x02, 0x8a, 0x1e, 0x43, 0xf5, 0x26,
	0x55, 0x1b, 0x77, 0xda, 0xd9, 0xfd, 0x8f, 0xfe, 0xb3, 0x7f, 0x93, 0xd9, 0xd3, 0xb3, 0xb7, 0xd6,
	0xb8, 0x11, 0xa7, 0xaa, 0x5f, 0x3b, 0x33, 0xda, 0x21, 0x8b, 0x51, 0x3f, 0xfb, 0xf9, 0x6f, 0x7f,
	0x3c, 0x2d, 0x9d, 0x46, 0x27, 0xcd, 0x8b, 0x32, 0xab, 0x92, 0x7e, 0xb0, 0xe2, 0x94, 0x5d, 0xce,
	0x6b, 0xfc, 0x9d, 0x03, 0x4b, 0xba, 0x79, 0x0e, 0x34, 0x84, 0x44, 0xe7, 0x46, 0xa7, 0xd0, 0x8c,
	0xf7, 0x53, 0xf3, 0x3c, 0xad, 0x5d, 0x19, 0xa7, 0xcd, 0x34, 0x71, 0xb4, 0x30, 0x52, 0xc8, 0xfe,
	0xd4, 0x81, 0xa3, 0x37, 0xe9, 0x41, 0x5d, 0xe8, 0xec, 0x68, 0x59, 0xed, 0xad, 0x5c, 0xd4, 0x58,
	0xbd, 0x5f, 0x5f, 0x35, 0x82, 0xea, 0x68, 0xe5, 0x25, 0x82, 0x9a, 0x9f, 0x32, 0xf2, 0x19, 0xfa,
	0xd1, 0x81, 0x85, 0xfd, 0x4d, 0x86, 0xd6, 0xc7, 0xef, 0xc8, 0xda, 0x3f, 0x98, 0xbe, 0xf5, 0x75,
	0x23, 0xeb, 0x52, 0xfd, 0x7f, 0x87, 0xc9, 0x6a, 0xda, 0x27, 0xef, 0x75, 0xe7, 0x02, 0xfa, 0xda,
	0x81, 0x05, 0x3b, 0x47, 0xc6, 0x2d, 0xd9, 0xab, 0x55, 0x64, 0xa7, 0x9f, 0x56, 0xf4, 0xbd, 0x03,
	0x27, 0x36, 0x23, 0x9e, 0x14, 0x04, 0xbd, 0x2b, 0x78, 0x6c, 0x87, 0xea, 0xab, 0x93, 0xb6, 0x66,
	0xa4, 0x5d, 0xac, 0x9f, 0x3f, 0xbc, 0x58, 0x5a, 0xcc, 0x75, 0xe7, 0x42, 0xeb, 0xed, 0x9f, 0x9f,
	0x2f, 0x3b, 0xbf, 0x3e, 0x5f, 0x76, 0x9e, 0x3d, 0x5f, 0x76, 0x7e, 0xf8, 0x7d, 0xf9, 0x5f, 0x1f,
	0x5d, 0x2c, 0xfc, 0xff, 0x96, 0xa7, 0xbc, 0x1c, 0xe3, 0x04, 0x87, 0x94, 0xe8, 0xb8, 0xb2, 0x10,
	0xb8, 0x33, 0x69, 0xe6, 0xf8, 0xd5, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xab, 0x4b, 0xba, 0xb6,
	0x4b, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PrepaidServiceClient is the client API for PrepaidService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PrepaidServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error)
	// Fetch all prepaid deployments for organization.
	// Required permissions:
	// - prepaid.deployment.list on the organization
	ListPrepaidDeployments(ctx context.Context, in *v11.ListOptions, opts ...grpc.CallOption) (*PrepaidDeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - prepaid.deployment.get on the deployment identified by the given ID
	GetPrepaidDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*PrepaidDeployment, error)
	// Creates a new deployment from a prepaid deployment and attached the newly created deployment to the prepaid deployment.
	// Required permissions:
	// - prepaid.deployment.create on the organization that owns the deployment
	CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error)
	// Update the deployment by prepaid deployment's id
	// Required permissions:
	// - prepaid.deployment.update on the organization that owns the deployment
	UpdateDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*v1.Deployment, error)
	// Creates a cloned deployment from a backup and attaches it to the prepaid deployment. This takes the deployment specification from the prepaid deployment, which must match the specification mentioned in the backup.
	// Required permissions:
	// - prepaid.deployment.create on the organization that owns the deployment
	CloneDeploymentFromBackup(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*v1.Deployment, error)
}

type prepaidServiceClient struct {
	cc *grpc.ClientConn
}

func NewPrepaidServiceClient(cc *grpc.ClientConn) PrepaidServiceClient {
	return &prepaidServiceClient{cc}
}

func (c *prepaidServiceClient) GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error) {
	out := new(v11.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) ListPrepaidDeployments(ctx context.Context, in *v11.ListOptions, opts ...grpc.CallOption) (*PrepaidDeploymentList, error) {
	out := new(PrepaidDeploymentList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/ListPrepaidDeployments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) GetPrepaidDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*PrepaidDeployment, error) {
	out := new(PrepaidDeployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/GetPrepaidDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) UpdateDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/UpdateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) CloneDeploymentFromBackup(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/CloneDeploymentFromBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PrepaidServiceServer is the server API for PrepaidService service.
type PrepaidServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v11.Empty) (*v11.Version, error)
	// Fetch all prepaid deployments for organization.
	// Required permissions:
	// - prepaid.deployment.list on the organization
	ListPrepaidDeployments(context.Context, *v11.ListOptions) (*PrepaidDeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - prepaid.deployment.get on the deployment identified by the given ID
	GetPrepaidDeployment(context.Context, *v11.IDOptions) (*PrepaidDeployment, error)
	// Creates a new deployment from a prepaid deployment and attached the newly created deployment to the prepaid deployment.
	// Required permissions:
	// - prepaid.deployment.create on the organization that owns the deployment
	CreateDeployment(context.Context, *CreateDeploymentRequest) (*v1.Deployment, error)
	// Update the deployment by prepaid deployment's id
	// Required permissions:
	// - prepaid.deployment.update on the organization that owns the deployment
	UpdateDeployment(context.Context, *v11.IDOptions) (*v1.Deployment, error)
	// Creates a cloned deployment from a backup and attaches it to the prepaid deployment. This takes the deployment specification from the prepaid deployment, which must match the specification mentioned in the backup.
	// Required permissions:
	// - prepaid.deployment.create on the organization that owns the deployment
	CloneDeploymentFromBackup(context.Context, *v11.IDOptions) (*v1.Deployment, error)
}

// UnimplementedPrepaidServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPrepaidServiceServer struct {
}

func (*UnimplementedPrepaidServiceServer) GetAPIVersion(ctx context.Context, req *v11.Empty) (*v11.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedPrepaidServiceServer) ListPrepaidDeployments(ctx context.Context, req *v11.ListOptions) (*PrepaidDeploymentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrepaidDeployments not implemented")
}
func (*UnimplementedPrepaidServiceServer) GetPrepaidDeployment(ctx context.Context, req *v11.IDOptions) (*PrepaidDeployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrepaidDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) CreateDeployment(ctx context.Context, req *CreateDeploymentRequest) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) UpdateDeployment(ctx context.Context, req *v11.IDOptions) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) CloneDeploymentFromBackup(ctx context.Context, req *v11.IDOptions) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloneDeploymentFromBackup not implemented")
}

func RegisterPrepaidServiceServer(s *grpc.Server, srv PrepaidServiceServer) {
	s.RegisterService(&_PrepaidService_serviceDesc, srv)
}

func _PrepaidService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).GetAPIVersion(ctx, req.(*v11.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_ListPrepaidDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).ListPrepaidDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/ListPrepaidDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).ListPrepaidDeployments(ctx, req.(*v11.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_GetPrepaidDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).GetPrepaidDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/GetPrepaidDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).GetPrepaidDeployment(ctx, req.(*v11.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).CreateDeployment(ctx, req.(*CreateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_UpdateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).UpdateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/UpdateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).UpdateDeployment(ctx, req.(*v11.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_CloneDeploymentFromBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).CloneDeploymentFromBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/CloneDeploymentFromBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).CloneDeploymentFromBackup(ctx, req.(*v11.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

var _PrepaidService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.prepaid.v1.PrepaidService",
	HandlerType: (*PrepaidServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _PrepaidService_GetAPIVersion_Handler,
		},
		{
			MethodName: "ListPrepaidDeployments",
			Handler:    _PrepaidService_ListPrepaidDeployments_Handler,
		},
		{
			MethodName: "GetPrepaidDeployment",
			Handler:    _PrepaidService_GetPrepaidDeployment_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _PrepaidService_CreateDeployment_Handler,
		},
		{
			MethodName: "UpdateDeployment",
			Handler:    _PrepaidService_UpdateDeployment_Handler,
		},
		{
			MethodName: "CloneDeploymentFromBackup",
			Handler:    _PrepaidService_CloneDeploymentFromBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prepaid.proto",
}

func (m *PrepaidDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BackupRestore != nil {
		{
			size, err := m.BackupRestore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x8a
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xea
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if len(m.IpallowlistId) > 0 {
		i -= len(m.IpallowlistId)
		copy(dAtA[i:], m.IpallowlistId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.IpallowlistId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xea
	}
	if len(m.IamproviderId) > 0 {
		i -= len(m.IamproviderId)
		copy(dAtA[i:], m.IamproviderId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.IamproviderId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe2
	}
	if len(m.CustomImage) > 0 {
		i -= len(m.CustomImage)
		copy(dAtA[i:], m.CustomImage)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.CustomImage)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd2
	}
	if m.UpgradeRecommendation != nil {
		{
			size, err := m.UpgradeRecommendation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if m.ReplaceVersionBy != nil {
		{
			size, err := m.ReplaceVersionBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if m.Servers != nil {
		{
			size, err := m.Servers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.CreatedById) > 0 {
		i -= len(m.CreatedById)
		copy(dAtA[i:], m.CreatedById)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.CreatedById)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SupportPlanId) > 0 {
		i -= len(m.SupportPlanId)
		copy(dAtA[i:], m.SupportPlanId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.SupportPlanId)))
		i--
		dAtA[i] = 0x52
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_ServersSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_ServersSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_ServersSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinimumDbserversCount != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.MinimumDbserversCount))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DbserverArgs) > 0 {
		for iNdEx := len(m.DbserverArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DbserverArgs[iNdEx])
			copy(dAtA[i:], m.DbserverArgs[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.DbserverArgs[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x68
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x60
	}
	if m.Dbservers != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x58
	}
	if len(m.CoordinatorArgs) > 0 {
		for iNdEx := len(m.CoordinatorArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CoordinatorArgs[iNdEx])
			copy(dAtA[i:], m.CoordinatorArgs[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.CoordinatorArgs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.Coordinators != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeDiskSize != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.NodeDiskSize))
		i--
		dAtA[i] = 0x20
	}
	if m.NodeCount != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_Expiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_Expiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_Expiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for iNdEx := len(m.LastWarningEmailSendTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LastWarningEmailSendTo[iNdEx])
			copy(dAtA[i:], m.LastWarningEmailSendTo[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.LastWarningEmailSendTo[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastWarningEmailSendAt != nil {
		{
			size, err := m.LastWarningEmailSendAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExpiresAt != nil {
		{
			size, err := m.ExpiresAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_BackupRestoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_BackupRestoreSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_BackupRestoreSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BackupId) > 0 {
		i -= len(m.BackupId)
		copy(dAtA[i:], m.BackupId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.BackupId)))
		i--
		dAtA[i] = 0x52
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Revision != 0 {
		i = encodeVarintPrepaid(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeploymentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeploymentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeploymentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPrepaid(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateDeploymentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDeploymentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDeploymentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Certificates != nil {
		{
			size, err := m.Certificates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpallowlistId) > 0 {
		i -= len(m.IpallowlistId)
		copy(dAtA[i:], m.IpallowlistId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.IpallowlistId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDeploymentRequest_CertificateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDeploymentRequest_CertificateSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDeploymentRequest_CertificateSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AlternateDnsNames) > 0 {
		for iNdEx := len(m.AlternateDnsNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlternateDnsNames[iNdEx])
			copy(dAtA[i:], m.AlternateDnsNames[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.AlternateDnsNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CaCertificateId) > 0 {
		i -= len(m.CaCertificateId)
		copy(dAtA[i:], m.CaCertificateId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.CaCertificateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPrepaid(dAtA []byte, offset int, v uint64) int {
	offset -= sovPrepaid(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PrepaidDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	l = len(m.SupportPlanId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.CreatedById)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.Locked {
		n += 2
	}
	if m.Servers != nil {
		l = m.Servers.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.ReplaceVersionBy != nil {
		l = m.ReplaceVersionBy.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.UpgradeRecommendation != nil {
		l = m.UpgradeRecommendation.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	l = len(m.CustomImage)
	if l > 0 {
		n += 2 + l + sovPrepaid(uint64(l))
	}
	l = len(m.IamproviderId)
	if l > 0 {
		n += 2 + l + sovPrepaid(uint64(l))
	}
	l = len(m.IpallowlistId)
	if l > 0 {
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.BackupRestore != nil {
		l = m.BackupRestore.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_ServersSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != 0 {
		n += 1 + sovPrepaid(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovPrepaid(uint64(m.CoordinatorMemorySize))
	}
	if len(m.CoordinatorArgs) > 0 {
		for _, s := range m.CoordinatorArgs {
			l = len(s)
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.Dbservers != 0 {
		n += 1 + sovPrepaid(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovPrepaid(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovPrepaid(uint64(m.DbserverDiskSize))
	}
	if len(m.DbserverArgs) > 0 {
		for _, s := range m.DbserverArgs {
			l = len(s)
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.MinimumDbserversCount != 0 {
		n += 1 + sovPrepaid(uint64(m.MinimumDbserversCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovPrepaid(uint64(m.NodeCount))
	}
	if m.NodeDiskSize != 0 {
		n += 1 + sovPrepaid(uint64(m.NodeDiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_Expiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiresAt != nil {
		l = m.ExpiresAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.LastWarningEmailSendAt != nil {
		l = m.LastWarningEmailSendAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for _, s := range m.LastWarningEmailSendTo {
			l = len(s)
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_BackupRestoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovPrepaid(uint64(m.Revision))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.BackupId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeploymentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDeploymentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.IpallowlistId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.Certificates != nil {
		l = m.Certificates.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDeploymentRequest_CertificateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaCertificateId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if len(m.AlternateDnsNames) > 0 {
		for _, s := range m.AlternateDnsNames {
			l = len(s)
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPrepaid(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPrepaid(x uint64) (n int) {
	return sovPrepaid(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PrepaidDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepaidDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepaidDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Servers == nil {
				m.Servers = &PrepaidDeployment_ServersSpec{}
			}
			if err := m.Servers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceVersionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplaceVersionBy == nil {
				m.ReplaceVersionBy = &v1.ReplaceVersionBy{}
			}
			if err := m.ReplaceVersionBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeRecommendation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeRecommendation == nil {
				m.UpgradeRecommendation = &v1.UpgradeVersionRecommendation{}
			}
			if err := m.UpgradeRecommendation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &PrepaidDeployment_ModelSpec{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IamproviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IamproviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpallowlistId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpallowlistId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PrepaidDeployment_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &PrepaidDeployment_Expiration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 401:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupRestore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupRestore == nil {
				m.BackupRestore = &PrepaidDeployment_BackupRestoreSpec{}
			}
			if err := m.BackupRestore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_ServersSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoordinatorArgs = append(m.CoordinatorArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbserverArgs = append(m.DbserverArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumDbserversCount", wireType)
			}
			m.MinimumDbserversCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumDbserversCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiskSize", wireType)
			}
			m.NodeDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &v1.Deployment{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_Expiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = &types.Timestamp{}
			}
			if err := m.ExpiresAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastWarningEmailSendAt == nil {
				m.LastWarningEmailSendAt = &types.Timestamp{}
			}
			if err := m.LastWarningEmailSendAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastWarningEmailSendTo = append(m.LastWarningEmailSendTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_BackupRestoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRestoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRestoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeploymentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepaidDeploymentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepaidDeploymentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &PrepaidDeployment{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDeploymentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDeploymentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDeploymentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpallowlistId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpallowlistId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Certificates == nil {
				m.Certificates = &CreateDeploymentRequest_CertificateSpec{}
			}
			if err := m.Certificates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDeploymentRequest_CertificateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateDnsNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateDnsNames = append(m.AlternateDnsNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrepaid(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPrepaid
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPrepaid
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPrepaid
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPrepaid(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPrepaid
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPrepaid = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrepaid   = fmt.Errorf("proto: integer overflow")
)
